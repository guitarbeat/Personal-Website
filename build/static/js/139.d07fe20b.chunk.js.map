{"version":3,"file":"static/js/139.d07fe20b.chunk.js","mappings":"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","sources":["components/Tools/snake/snake.js","components/Tools/snake/index.js","components/Tools/snake/hooks/index.js"],"sourcesContent":["import { Scene } from 'phaser';\n\n// Constants\nconst GRID_SIZE = 20;\nconst SNAKE_SPEED = 150;\nconst COLORS = {\n  SNAKE_HEAD: 0x00ff00,\n  SNAKE_BODY: 0x00cc00,\n  FOOD: 0xff0000,\n  GRID: 0x333333,\n};\n\nexport class SnakeScene extends Scene {\n  constructor() {\n    super({ key: 'SnakeScene' });\n  }\n\n  init() {\n    this.snake = [];\n    this.food = null;\n    this.direction = 'RIGHT';\n    this.nextDirection = 'RIGHT';\n    this.score = 0;\n    this.gameOver = false;\n    this.lastUpdate = 0;\n  }\n\n  preload() {\n    // Ensure the scene is ready for rendering\n    this.load.on('complete', () => {\n      console.log('Scene assets loaded');\n    });\n  }\n\n  create() {\n    try {\n      this.initializeGame();\n      this.setupControls();\n      this.createInitialSnake();\n      this.spawnFood();\n      \n      // Update game state\n      if (window.g?.setState) {\n        window.g.setState('playing');\n      }\n    } catch (error) {\n      console.error('Error in scene creation:', error);\n      if (this.game.config.callbacks?.postBoot) {\n        this.game.config.callbacks.postBoot();\n      }\n    }\n  }\n\n  initializeGame() {\n    // Calculate grid size and dimensions\n    const width = this.game.config.width;\n    const height = this.game.config.height;\n    \n    this.gridWidth = Math.floor(width / GRID_SIZE);\n    this.gridHeight = Math.floor(height / GRID_SIZE);\n    \n    // Create grid background\n    this.createGrid(width, height);\n    \n    // Initialize score text\n    this.scoreText = this.add.text(16, 16, 'Score: 0', {\n      fontFamily: '\"Press Start 2P\", monospace',\n      fontSize: '16px',\n      fill: '#fff'\n    });\n  }\n\n  createGrid(width, height) {\n    const grid = this.add.graphics();\n    grid.lineStyle(1, COLORS.GRID, 0.3);\n    \n    // Draw vertical lines\n    for (let x = 0; x <= this.gridWidth; x++) {\n      const xPos = x * GRID_SIZE;\n      grid.beginPath();\n      grid.moveTo(xPos, 0);\n      grid.lineTo(xPos, height);\n      grid.strokePath();\n    }\n    \n    // Draw horizontal lines\n    for (let y = 0; y <= this.gridHeight; y++) {\n      const yPos = y * GRID_SIZE;\n      grid.beginPath();\n      grid.moveTo(0, yPos);\n      grid.lineTo(width, yPos);\n      grid.strokePath();\n    }\n  }\n\n  setupControls() {\n    // Keyboard controls\n    this.cursors = this.input.keyboard.createCursorKeys();\n    \n    // Touch controls\n    this.input.on('pointerdown', (pointer) => {\n      const centerX = this.game.config.width / 2;\n      const centerY = this.game.config.height / 2;\n      \n      // Determine swipe direction based on touch position\n      if (Math.abs(pointer.x - centerX) > Math.abs(pointer.y - centerY)) {\n        // Horizontal movement\n        if (pointer.x > centerX && this.direction !== 'LEFT') {\n          this.nextDirection = 'RIGHT';\n        } else if (pointer.x < centerX && this.direction !== 'RIGHT') {\n          this.nextDirection = 'LEFT';\n        }\n      } else {\n        // Vertical movement\n        if (pointer.y > centerY && this.direction !== 'UP') {\n          this.nextDirection = 'DOWN';\n        } else if (pointer.y < centerY && this.direction !== 'DOWN') {\n          this.nextDirection = 'UP';\n        }\n      }\n    });\n  }\n\n  createInitialSnake() {\n    const startX = Math.floor(this.gridWidth / 4);\n    const startY = Math.floor(this.gridHeight / 2);\n    \n    // Create snake head\n    const head = this.add.rectangle(\n      startX * GRID_SIZE,\n      startY * GRID_SIZE,\n      GRID_SIZE - 2,\n      GRID_SIZE - 2,\n      COLORS.SNAKE_HEAD\n    );\n    \n    // Create initial body segments\n    const body1 = this.add.rectangle(\n      (startX - 1) * GRID_SIZE,\n      startY * GRID_SIZE,\n      GRID_SIZE - 2,\n      GRID_SIZE - 2,\n      COLORS.SNAKE_BODY\n    );\n    \n    const body2 = this.add.rectangle(\n      (startX - 2) * GRID_SIZE,\n      startY * GRID_SIZE,\n      GRID_SIZE - 2,\n      GRID_SIZE - 2,\n      COLORS.SNAKE_BODY\n    );\n    \n    this.snake = [head, body1, body2];\n  }\n\n  spawnFood() {\n    let x, y;\n    do {\n      x = Math.floor(Math.random() * this.gridWidth);\n      y = Math.floor(Math.random() * this.gridHeight);\n    } while (this.isPositionOccupied(x, y));\n    \n    if (this.food) {\n      this.food.destroy();\n    }\n    \n    this.food = this.add.rectangle(\n      x * GRID_SIZE,\n      y * GRID_SIZE,\n      GRID_SIZE - 2,\n      GRID_SIZE - 2,\n      COLORS.FOOD\n    );\n  }\n\n  isPositionOccupied(x, y) {\n    return this.snake.some(segment => {\n      const segX = Math.floor(segment.x / GRID_SIZE);\n      const segY = Math.floor(segment.y / GRID_SIZE);\n      return segX === x && segY === y;\n    });\n  }\n\n  update(time) {\n    if (this.gameOver) {\n      return;\n    }\n\n    // Handle input\n    this.handleInput();\n    \n    // Move snake at fixed intervals\n    if (time - this.lastUpdate > SNAKE_SPEED) {\n      this.moveSnake();\n      this.lastUpdate = time;\n    }\n  }\n\n  handleInput() {\n    if (this.cursors.left.isDown && this.direction !== 'RIGHT') {\n      this.nextDirection = 'LEFT';\n    } else if (this.cursors.right.isDown && this.direction !== 'LEFT') {\n      this.nextDirection = 'RIGHT';\n    } else if (this.cursors.up.isDown && this.direction !== 'DOWN') {\n      this.nextDirection = 'UP';\n    } else if (this.cursors.down.isDown && this.direction !== 'UP') {\n      this.nextDirection = 'DOWN';\n    }\n  }\n\n  moveSnake() {\n    // Update direction\n    this.direction = this.nextDirection;\n    \n    // Calculate new head position\n    const head = this.snake[0];\n    const headX = head.x / GRID_SIZE;\n    const headY = head.y / GRID_SIZE;\n    \n    let newX = headX;\n    let newY = headY;\n    \n    switch (this.direction) {\n      case 'LEFT':\n        newX = (headX - 1 + this.gridWidth) % this.gridWidth;\n        break;\n      case 'RIGHT':\n        newX = (headX + 1) % this.gridWidth;\n        break;\n      case 'UP':\n        newY = (headY - 1 + this.gridHeight) % this.gridHeight;\n        break;\n      case 'DOWN':\n        newY = (headY + 1) % this.gridHeight;\n        break;\n      default:\n        // If an unexpected direction is given, maintain current position\n        console.warn('Unexpected direction:', this.direction);\n        break;\n    }\n    \n    // Check for collision with self\n    if (this.isPositionOccupied(newX, newY)) {\n      this.gameOver = true;\n      this.handleGameOver();\n      return;\n    }\n    \n    // Check for food collision\n    const foodX = Math.floor(this.food.x / GRID_SIZE);\n    const foodY = Math.floor(this.food.y / GRID_SIZE);\n    \n    if (newX === foodX && newY === foodY) {\n      this.score += 10;\n      this.scoreText.setText(`Score: ${this.score}`);\n      this.spawnFood();\n    } else {\n      // Remove tail if no food was eaten\n      this.snake.pop().destroy();\n    }\n    \n    // Create new head\n    const newHead = this.add.rectangle(\n      newX * GRID_SIZE,\n      newY * GRID_SIZE,\n      GRID_SIZE - 2,\n      GRID_SIZE - 2,\n      COLORS.SNAKE_HEAD\n    );\n    \n    // Update old head color\n    head.setFillStyle(COLORS.SNAKE_BODY);\n    \n    // Add new head to snake array\n    this.snake.unshift(newHead);\n  }\n\n  handleGameOver() {\n    this.gameOver = true;\n    this.scene.pause();\n    \n    // Save highscore\n    const playerName = prompt('Game Over! Enter your name for the highscore:');\n    if (playerName) {\n      import('../../../config/googleApps').then(({ makeApiCall }) => {\n        makeApiCall('updateSheetData', {\n          tabName: 'SNAKE',\n          playerName: playerName,\n          score: this.score\n        }).then(response => {\n          if (response.success) {\n            alert(`Congratulations! You ranked #${response.rank} on the leaderboard!\\n\\n` +\n                  'Top 10 Scores:\\n' +\n                  response.topScores.map(s => `${s.name}: ${s.score}`).join('\\n'));\n          } else {\n            console.error('Failed to save highscore:', response.error);\n          }\n        }).catch(error => {\n          console.error('Error saving highscore:', error);\n        });\n      }).catch(error => {\n        console.error('Error importing googleApps:', error);\n      });\n    }\n    \n    // Update game state\n    if (window.g?.setState) {\n      window.g.setState('gameover');\n    }\n    \n    // Show game over text\n    const centerX = this.game.config.width / 2;\n    const centerY = this.game.config.height / 2;\n    \n    this.add.text(centerX, centerY - 30, 'GAME OVER', {\n      fontFamily: '\"Press Start 2P\", monospace',\n      fontSize: '32px',\n      fill: '#ff0000',\n      align: 'center'\n    }).setOrigin(0.5);\n    \n    this.add.text(centerX, centerY + 30, 'Press SPACE to restart', {\n      fontFamily: '\"Press Start 2P\", monospace',\n      fontSize: '16px',\n      fill: '#fff',\n      align: 'center'\n    }).setOrigin(0.5);\n    \n    // Add restart handler\n    this.input.keyboard.once('keydown-SPACE', () => {\n      this.scene.restart();\n    });\n  }\n}","// External dependencies\nimport React, { useEffect, useRef, useCallback, memo } from 'react';\nimport { Game, AUTO, Scale } from 'phaser';\n\n// Local imports\nimport FullscreenWrapper from '../FullscreenWrapper';\n\n// Game components and hooks\nimport { SnakeScene } from './snake';\nimport { useGameState } from './hooks';\n\n// Styles\nimport './snake.css';\n\n// Game configuration\nconst GAME_CONFIG = {\n  width: 800,\n  height: 600,\n  backgroundColor: '#1E1E2E',\n  pixelArt: true,\n  antialias: false,\n  roundPixels: true,\n  scale: {\n    mode: Scale.FIT,\n    autoCenter: Scale.CENTER_BOTH,\n    width: 800,\n    height: 600,\n    zoom: 1\n  },\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 0 },\n      debug: false\n    }\n  }\n};\n\n/**\n * Initialize game namespace\n * @returns {Object} Game namespace object\n */\nconst initializeGameNamespace = () => {\n  if (typeof window === 'undefined') return null;\n  \n  if (!window.g) {\n    window.g = {\n      m: Math,\n      states: {},\n      state: 'play',\n      config: {\n        title: 'Snakely',\n        debug: false,\n        state: 'play'\n      },\n      addState(state) {\n        if (!state?.name) return;\n        this.states[state.name] = state;\n      },\n      setState(name) {\n        if (!this.states[name]) return;\n        \n        if (this.state && this.states[this.state]) {\n          this.states[this.state].exit?.();\n        }\n        this.state = name;\n        this.states[this.state].init?.();\n      }\n    };\n  }\n  return window.g;\n};\n\n/**\n * Load VFX script and initialize effects\n * @param {React.RefObject} containerRef - Reference to container element\n * @param {React.RefObject} vfxRef - Reference to VFX instance\n * @returns {Promise<void>}\n */\nconst loadVFXScript = async (containerRef, vfxRef) => {\n  if (typeof window === 'undefined' || !containerRef.current || vfxRef.current) return;\n\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.src = 'https://cdn.jsdelivr.net/gh/Amagitechnologies/vfx-js@latest/dist/vfx.min.js';\n    script.async = true;\n    \n    script.onload = () => {\n      if (containerRef.current && !vfxRef.current) {\n        try {\n          vfxRef.current = new window.VFX({\n            container: containerRef.current,\n            effects: {}\n          });\n          resolve();\n        } catch (error) {\n          console.warn('Failed to initialize VFX:', error);\n          reject(error);\n        }\n      }\n    };\n    \n    script.onerror = (error) => {\n      console.warn('Failed to load VFX script:', error);\n      reject(error);\n    };\n    \n    document.body.appendChild(script);\n  });\n};\n\n/**\n * Snake Game Component\n */\nconst SnakeGame = memo(() => {\n  const gameRef = useRef(null);\n  const containerRef = useRef(null);\n  const vfxRef = useRef(null);\n  const { gameState, updateGameState } = useGameState();\n\n  // Initialize game instance\n  const initializeGame = useCallback(() => {\n    if (!containerRef.current || gameRef.current) return;\n\n    try {\n      gameRef.current = new Game({\n        ...GAME_CONFIG,\n        type: AUTO,\n        parent: containerRef.current,\n        scene: SnakeScene,\n        callbacks: {\n          postBoot: () => {\n            updateGameState({ status: 'ready' });\n          }\n        }\n      });\n\n      // Handle resize events\n      window.addEventListener('resize', () => {\n        if (gameRef.current) {\n          gameRef.current.scale.refresh();\n        }\n      });\n    } catch (error) {\n      console.error('Failed to initialize game:', error);\n      updateGameState({ status: 'error', error });\n    }\n  }, [updateGameState]);\n\n  // Initialize game namespace and VFX\n  useEffect(() => {\n    initializeGameNamespace();\n    loadVFXScript(containerRef, vfxRef).catch(console.warn);\n\n    return () => {\n      // Cleanup\n      if (gameRef.current) {\n        gameRef.current.destroy(true);\n        gameRef.current = null;\n      }\n      if (vfxRef.current) {\n        vfxRef.current.destroy?.();\n        vfxRef.current = null;\n      }\n    };\n  }, []);\n\n  // Initialize game after container is ready\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      initializeGame();\n    }, 100);\n\n    return () => {\n      clearTimeout(timer);\n      window.removeEventListener('resize', () => {\n        if (gameRef.current) {\n          gameRef.current.scale.refresh();\n        }\n      });\n      if (gameRef.current) {\n        gameRef.current.destroy(true);\n        gameRef.current = null;\n      }\n    };\n  }, [initializeGame]);\n\n  return (\n    <FullscreenWrapper>\n      <div \n        ref={containerRef}\n        className=\"snake-game-container\"\n        role=\"application\"\n        aria-label=\"Snake Game\"\n      />\n      {gameState.status === 'error' && (\n        <div className=\"snake-game-error\">\n          Failed to load game. Please refresh the page.\n        </div>\n      )}\n    </FullscreenWrapper>\n  );\n});\n\nSnakeGame.displayName = 'SnakeGame';\n\nexport default SnakeGame;\n","import { useState, useCallback } from 'react';\n\n/**\n * Custom hook for managing game state\n * @returns {Object} Game state and update function\n */\nexport const useGameState = () => {\n  const [gameState, setGameState] = useState({\n    status: 'initializing',\n    score: 0,\n    highScore: typeof window !== 'undefined' ? \n      localStorage.getItem('snakeHighScore') || 0 : 0,\n    error: null\n  });\n\n  const updateGameState = useCallback((update) => {\n    setGameState(prevState => {\n      const newState = { ...prevState, ...update };\n      \n      if (typeof window !== 'undefined' && newState.score > newState.highScore) {\n        newState.highScore = newState.score;\n        localStorage.setItem('snakeHighScore', newState.highScore);\n      }\n      \n      return newState;\n    });\n  }, []);\n\n  return { gameState, updateGameState };\n};\n"],"names":["GRID_SIZE","COLORS","SnakeScene","Scene","constructor","super","key","init","this","snake","food","direction","nextDirection","score","gameOver","lastUpdate","preload","load","on","console","log","create","_window$g","initializeGame","setupControls","createInitialSnake","spawnFood","window","g","setState","error","_this$game$config$cal","game","config","callbacks","postBoot","width","height","gridWidth","Math","floor","gridHeight","createGrid","scoreText","add","text","fontFamily","fontSize","fill","grid","graphics","lineStyle","x","xPos","beginPath","moveTo","lineTo","strokePath","y","yPos","cursors","input","keyboard","createCursorKeys","pointer","centerX","centerY","abs","startX","startY","head","rectangle","body1","body2","random","isPositionOccupied","destroy","some","segment","segX","segY","update","time","handleInput","moveSnake","left","isDown","right","up","down","headX","headY","newX","newY","warn","handleGameOver","foodX","foodY","setText","pop","newHead","setFillStyle","unshift","_window$g2","scene","pause","playerName","prompt","then","_ref","makeApiCall","tabName","response","success","alert","rank","topScores","map","s","name","join","catch","align","setOrigin","once","restart","GAME_CONFIG","backgroundColor","pixelArt","antialias","roundPixels","scale","mode","Scale","FIT","autoCenter","CENTER_BOTH","zoom","physics","default","arcade","gravity","debug","initializeGameNamespace","m","states","state","title","addState","_this$states$this$sta3","_this$states$this$sta4","_this$states$this$sta","_this$states$this$sta2","exit","call","SnakeGame","memo","gameRef","useRef","containerRef","vfxRef","gameState","updateGameState","useGameState","setGameState","useState","status","highScore","localStorage","getItem","useCallback","prevState","newState","setItem","current","Game","type","AUTO","parent","addEventListener","refresh","useEffect","async","Promise","resolve","reject","script","document","createElement","src","onload","VFX","container","effects","onerror","body","appendChild","loadVFXScript","_vfxRef$current$destr","_vfxRef$current","timer","setTimeout","clearTimeout","removeEventListener","_jsxs","FullscreenWrapper","children","_jsx","ref","className","role","displayName"],"sourceRoot":""}