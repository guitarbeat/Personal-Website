{"version":3,"file":"static/js/658.7d9e9704.chunk.js","mappings":"iJACO,MAAMA,EACH,CACNC,WAAY,wBACZC,MAAO,CACLC,SAAU,CAAC,UAAW,UAAW,WACjCC,KAAM,WAERC,UAAW,CACTF,SAAU,CAAC,UAAW,WACtBC,KAAM,WAERE,KAAM,CACJH,SAAU,CAAC,UAAW,WACtBC,KAAM,WAERG,OAAQ,UACRC,UAAW,4BACXC,KAAM,UACNC,SAAU,UACVC,gBAAiB,wBACjBC,UAAW,WApBFZ,EAuBC,CACVa,YAAa,GACbC,YAAa,GACbC,aAAc,EACdC,cAAe,EACfC,WAAY,GACZC,WAAY,GACZC,gBAAiB,IA9BRnB,EAiCC,CACVoB,WAAY,CACVC,OAAQ,IACRC,QAAS,IAEXC,UAAW,IACXC,aAAc,KACdC,eAAgB,KAChBC,eAAgB,KAChBC,mBAAoB,GACpBC,iBAAkB,IAClBC,cAAe,GACfC,iBAAkB,IAClBC,gBAAiB,GACjBC,cAAe,EACfC,aAAc,IAKLC,EACO,IAOPC,EAAc,CACzBC,SAAU,GACVC,mBAAoB,EACpBC,WAAY,EACZC,cAAe,EACfC,SAAU,CACRC,GAAI,CAAC,UAAW,IAAK,KACrBC,KAAM,CAAC,YAAa,IAAK,KACzBC,KAAM,CAAC,YAAa,IAAK,KACzBC,MAAO,CAAC,aAAc,IAAK,KAC3BC,MAAO,CAAC,QAAS,IAAK,KACtBC,QAAS,CAAC,IAAK,O,kCCEnB,MAAMC,EAAe,IAzErB,MACIC,WAAAA,GAEIC,KAAKC,UAAY,IAAIC,EAAAA,GAAW,CAC5BC,WAAY,CACRC,KAAM,QAEVC,SAAU,CACNC,OAAQ,IACRC,MAAO,GACPC,QAAS,EACTC,QAAS,MAEdC,gBAEHV,KAAKW,cAAgB,IAAIT,EAAAA,GAAeA,EAAAA,GAAY,CAChDC,WAAY,CACRC,KAAM,YAEVC,SAAU,CACNC,OAAQ,IACRC,MAAO,GACPC,QAAS,EACTC,QAAS,MAEdC,gBAEHV,KAAKY,UAAY,IAAIV,EAAAA,GAAW,CAC5BC,WAAY,CACRC,KAAM,UAEVC,SAAU,CACNC,OAAQ,IACRC,MAAO,IACPC,QAAS,EACTC,QAAS,KAEbI,QAAS,KACVH,gBAGHV,KAAKc,cAAgB,IAAIZ,EAAAA,EAAmB,KAAM,IAAKQ,gBACvDV,KAAKW,cAAcI,QAAQf,KAAKc,cACpC,CAEA,gBAAME,GAEF,GAA2B,YAAvBd,EAAAA,GAAae,MACb,UACUf,EAAAA,KACNgB,QAAQC,IAAI,wBAChB,CAAE,MAAOC,GACLF,QAAQG,KAAK,iCAAkCD,EACnD,CAER,CAEAE,eAAAA,GACItB,KAAKC,UAAUsB,qBAAqB,KAAM,MAC9C,CAEAC,YAAAA,GAEI,MAAMC,EAAMvB,EAAAA,KACZF,KAAKW,cAAcY,qBAAqB,CAAC,KAAM,KAAM,KAAM,MAAO,KAAME,EAC5E,CAEAC,QAAAA,GACI1B,KAAKY,UAAUW,qBAAqB,KAAM,MAC9C,GC9DG,MAAMI,UAAmBC,EAAAA,MAC9B7B,WAAAA,GAA+B,IAAnB8B,EAAQC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAClBG,MAAM,CAAEC,IAAK,eACblC,KAAKiB,MAAQ,CACXhE,MAAO,GACPI,KAAM,KACN8E,UAAW,CAAEC,EAAG,EAAGC,EAAG,GACtBC,cAAe,CAAEF,EAAG,EAAGC,EAAG,GAC1BE,MAAO,EACP9E,UAAU,EACV+E,WAAY,GAEdxC,KAAKyC,UAAY,GACjBzC,KAAK0C,WAAa,EAClB1C,KAAK2C,SAAW,IAChB3C,KAAK4C,QAAU,EACf5C,KAAK6B,SAAWA,EAChB7B,KAAK6C,UAAYhB,EAAW9E,EAAiBoB,WAAWC,OAASrB,EAAiBoB,WAAWE,QAC7F2B,KAAKrC,UAAYmF,SAASC,aAAaC,QAAQ,oBAAsB,EACrEhD,KAAKiD,OAAS,IAAIC,MAClBlD,KAAKiD,OAAOE,IAAMC,EAClBpD,KAAKqD,gBAAkB,IACzB,CAEA,YAAMC,CAAOC,GACXvD,KAAKuD,WAAaA,EAClBvD,KAAKwD,SAAWD,EAAWC,eACrBC,EAAMzC,aACZhB,KAAK0D,iBACL1D,KAAK2D,aACL3D,KAAK4D,qBACP,CAEAF,cAAAA,GACE,MAAMG,EAAUC,KAAKC,MAAM7E,EAAYC,SAAW,GAAKa,KAAKwD,SACtDQ,EAAUF,KAAKC,MAAM7E,EAAYC,SAAW,GAAKa,KAAKwD,SAE5DxD,KAAKiB,MAAMhE,MAAQ,CAAC,CAAEmF,EAAGyB,EAASxB,EAAG2B,IACrChE,KAAKiB,MAAMkB,UAAY,CAAEC,EAAGpC,KAAKwD,SAAUnB,EAAG,GAC9CrC,KAAKiB,MAAMqB,cAAgB,CAAEF,EAAGpC,KAAKwD,SAAUnB,EAAG,GAClDrC,KAAKiE,YACLjE,KAAKiB,MAAMsB,MAAQ,EACnBvC,KAAKiB,MAAMxD,UAAW,CACxB,CAEAkG,UAAAA,GACE3D,KAAKqD,gBAAmBa,IACtBlE,KAAKmE,eAAeD,EAAME,MACtB,CAAC,UAAW,YAAa,YAAa,cAAcC,SAASH,EAAME,OACrEF,EAAMI,gBACR,EAEFC,SAASC,iBAAiB,UAAWxE,KAAKqD,gBAC5C,CAEAc,cAAAA,CAAejC,GACb,GAAIlC,KAAKiB,MAAMxD,WACD,UAARyE,GAA2B,UAARA,GAErB,YADAlC,KAAK0D,iBAKT,MAAM,UAAEvB,GAAcnC,KAAKiB,MACrBuC,EAAWxD,KAAKwD,SAEtB,OAAOtB,GACL,IAAK,UACiB,IAAhBC,EAAUE,IACZrC,KAAKiB,MAAMqB,cAAgB,CAAEF,EAAG,EAAGC,GAAImB,IAEzC,MACF,IAAK,YACiB,IAAhBrB,EAAUE,IACZrC,KAAKiB,MAAMqB,cAAgB,CAAEF,EAAG,EAAGC,EAAGmB,IAExC,MACF,IAAK,YACiB,IAAhBrB,EAAUC,IACZpC,KAAKiB,MAAMqB,cAAgB,CAAEF,GAAIoB,EAAUnB,EAAG,IAEhD,MACF,IAAK,aACiB,IAAhBF,EAAUC,IACZpC,KAAKiB,MAAMqB,cAAgB,CAAEF,EAAGoB,EAAUnB,EAAG,IAE/C,MACF,IAAK,QACL,IAAK,QACCrC,KAAKiB,MAAMxD,UACbuC,KAAK0D,iBAMb,CAEAe,oBAAAA,GAGE,MAAO,CAAErC,EAFC0B,KAAKC,MAAMD,KAAKY,UAAY1E,KAAKuD,WAAWoB,MAAQ3E,KAAKwD,WAAaxD,KAAKwD,SAEzEnB,EADFyB,KAAKC,MAAMD,KAAKY,UAAY1E,KAAKuD,WAAWqB,OAAS5E,KAAKwD,WAAaxD,KAAKwD,SAExF,CAEAqB,mBAAAA,CAAoBxH,GAClB,OAAQ2C,KAAKiB,MAAMhE,MAAM6H,MAAKC,GAAW/E,KAAKgF,YAAYD,EAAS1H,IACrE,CAEA4G,SAAAA,GACE,IAAIgB,EACJ,GACEA,EAAUjF,KAAKyE,8BACPzE,KAAK6E,oBAAoBI,IAEnCjF,KAAKiB,MAAM5D,KAAO4H,CACpB,CAEAD,WAAAA,CAAYE,EAAMC,GAChB,MAAMC,EAAYpF,KAAKwD,SAAW,EAClC,OAAOM,KAAKuB,IAAIH,EAAK9C,EAAI+C,EAAK/C,GAAKgD,GAAatB,KAAKuB,IAAIH,EAAK7C,EAAI8C,EAAK9C,GAAK+C,CAC9E,CAEAE,eAAAA,GACE,MAAM,KAAEjI,GAAS2C,KAAKiB,MAEhBsE,EAAUvF,KAAK4C,QAErB,IAAK,IAAI4C,EAAI,EAAGA,EAHM,GAGaA,IAAK,CACtC,MAAMC,EAAmB,EAAV3B,KAAK4B,GAASF,EAJT,GAKdG,EAAQ,EAAoB,EAAhB7B,KAAKY,SACjBkB,EAAO,EAAoB,EAAhB9B,KAAKY,SAEtB1E,KAAKyC,UAAUoD,KAAK,CAClBzD,EAAG/E,EAAK+E,EAAIpC,KAAKwD,SAAW,EAC5BnB,EAAGhF,EAAKgF,EAAIrC,KAAKwD,SAAW,EAC5BsC,GAAIhC,KAAKiC,IAAIN,GAASE,EACtBK,GAAIlC,KAAKmC,IAAIR,GAASE,EACtBC,OACAM,KAAM,EACNC,KAAMZ,EAA0B,GAAhBzB,KAAKY,UAAiB,IACtC0B,KAAM,WACJ,GAAIpG,KAAKkG,MAAQ,EAAG,OAEpB,MAAMG,EAAMrG,KAAKsG,KAAKC,QACtBF,EAAIG,YACJH,EAAII,UAAY,QAAQzG,KAAKmG,kBAAkBnG,KAAKkG,QACpDG,EAAIK,YAAc,QAAQ1G,KAAKmG,kBAAkBnG,KAAKkG,QACtDG,EAAIrI,WAAa,EACjBqI,EAAIM,SAAS3G,KAAKoC,EAAGpC,KAAKqC,EAAGrC,KAAK4F,KAAM5F,KAAK4F,MAC7CS,EAAIrI,WAAa,EAGjBgC,KAAKoC,GAAKpC,KAAK8F,GACf9F,KAAKqC,GAAKrC,KAAKgG,GACfhG,KAAKkG,MAAQ,GACf,EAAEU,KAAK5G,OAEX,CACF,CAEA6G,MAAAA,CAAOC,GACD9G,KAAKiB,MAAMxD,WAKfuC,KAAK2C,UAAY3C,KAAK2C,SAAW,IAAO,IACxC3C,KAAK4C,SAAW5C,KAAK4C,QAAU,GAAK,IAGhCkE,EAAO9G,KAAKiB,MAAMuB,WAAaxC,KAAK6C,YAIxC7C,KAAKiB,MAAMuB,WAAasE,EACxB9G,KAAK+G,YACD/G,KAAKgH,oBAGThH,KAAKoG,OACLpG,KAAKiH,oBACP,CAEAD,eAAAA,GACE,MAAM,MAAE/J,GAAU+C,KAAKiB,MACjBiG,EAAOjK,EAAM,GAGnB,IAAK,IAAIuI,EAAI,EAAGA,EAAIvI,EAAM8E,OAAQyD,IAChC,GAAIxF,KAAKgF,YAAYkC,EAAMjK,EAAMuI,IAG/B,OAFAxF,KAAKiB,MAAMxD,UAAW,EACtBgG,EAAMjC,gBACC,EAGX,OAAO,CACT,CAEAuF,SAAAA,GACE,MAAM,MAAE9J,EAAK,cAAEqF,EAAa,KAAEjF,GAAS2C,KAAKiB,MACtCiG,EAAO,IAAKjK,EAAM,IAExB+C,KAAKiB,MAAMkB,UAAYG,EACvB4E,EAAK9E,GAAKE,EAAcF,EACxB8E,EAAK7E,GAAKC,EAAcD,EAGxB,MAAMsC,EAAQ3E,KAAKuD,WAAWoB,MACxBC,EAAS5E,KAAKuD,WAAWqB,OAE3BsC,EAAK9E,GAAKuC,IAAOuC,EAAK9E,EAAI,GAC1B8E,EAAK9E,EAAI,IAAG8E,EAAK9E,EAAIuC,EAAQ3E,KAAKwD,UAClC0D,EAAK7E,GAAKuC,IAAQsC,EAAK7E,EAAI,GAC3B6E,EAAK7E,EAAI,IAAG6E,EAAK7E,EAAIuC,EAAS5E,KAAKwD,UAEvCvG,EAAMkK,QAAQD,GAGVlH,KAAKgF,YAAYkC,EAAM7J,IAEzBoG,EAAMnC,kBAGNtB,KAAKiB,MAAMsB,QAGXvC,KAAKsF,kBAGLtF,KAAKiE,YAGDjE,KAAKiB,MAAMsB,MAAQvC,KAAKrC,YAC1BqC,KAAKrC,UAAYqC,KAAKiB,MAAMsB,MAC5BQ,aAAaqE,QAAQ,iBAAkBpH,KAAKiB,MAAMsB,SAMpDtF,EAAMoK,KAEV,CAEAJ,eAAAA,GACE,IAAK,IAAIzB,EAAIxF,KAAKyC,UAAUV,OAAS,EAAGyD,GAAK,EAAGA,IAC9CxF,KAAKyC,UAAU+C,GAAGY,OACdpG,KAAKyC,UAAU+C,GAAGU,MAAQ,GAC5BlG,KAAKyC,UAAU6E,OAAO9B,EAAG,EAG/B,CAEAY,IAAAA,GACE,MAAM,MAAEnJ,EAAK,KAAEI,GAAS2C,KAAKiB,MACvBoF,EAAMrG,KAAKsG,KAAKC,QA0BtB,GAvBAF,EAAIkB,UAAU,EAAG,EAAGvH,KAAKuD,WAAWoB,MAAO3E,KAAKuD,WAAWqB,QAG3D5E,KAAKwH,WAGLvK,EAAMwK,SAAQ,CAAC1C,EAAS2C,KACtB,MAAMC,EAAmB,IAAVD,EACfrB,EAAIG,YAGJ,MAAMoB,GAAc5H,KAAK2C,SAAoB,EAAR+E,GAAc,IAC7CG,EAAY,OAAOD,WAAoBD,EAAS,GAAK,OACrDG,EAAY,OAAOF,eAEzBvB,EAAII,UAAYoB,EAChBxB,EAAIK,YAAcoB,EAClBzB,EAAIrI,WAAa2J,EAAS,GAAK,GAC/BtB,EAAIM,SAAS5B,EAAQ3C,EAAG2C,EAAQ1C,EAAGrC,KAAKwD,SAAW,EAAGxD,KAAKwD,SAAW,EAAE,IAE1E6C,EAAIrI,WAAa,EAGbX,EAAM,CACRgJ,EAAI0B,OAGJ,MAAMC,EAAY,OAAOhI,KAAK4C,qBACxBqF,EAAW,OAAOjI,KAAK4C,qBAG7ByD,EAAIK,YAAcuB,EAClB5B,EAAIrI,WAAa,GAGjBqI,EAAI6B,UACFlI,KAAKiD,OACL5F,EAAK+E,EACL/E,EAAKgF,EACLrC,KAAKwD,SAAW,EAChBxD,KAAKwD,SAAW,GAIlB6C,EAAI8B,yBAA2B,UAC/B9B,EAAII,UAAYuB,EAChB3B,EAAIM,SAAStJ,EAAK+E,EAAG/E,EAAKgF,EAAGrC,KAAKwD,SAAW,EAAGxD,KAAKwD,SAAW,GAGhE6C,EAAI8B,yBAA2B,cAC/B9B,EAAII,UAAY,2BAChB,MAAM2B,EAAY,EAClB,IAAK,IAAIhG,EAAI,EAAGA,EAAIpC,KAAKwD,SAAW,EAAGpB,GAAKgG,EAC1C,IAAK,IAAI/F,EAAI,EAAGA,EAAIrC,KAAKwD,SAAW,EAAGnB,GAAK+F,GACrChG,EAAIC,GAAK,IAAM,GAClBgE,EAAIM,SAAStJ,EAAK+E,EAAIA,EAAG/E,EAAKgF,EAAIA,EAAG+F,EAAWA,GAKtD/B,EAAIgC,SACN,CAGArI,KAAKyC,UAAUgF,SAAQa,GAAYA,EAASlC,QAC9C,CAEAoB,QAAAA,GACE,MAAMnB,EAAMrG,KAAKsG,KAAKC,QACtBF,EAAIkC,YAAcxL,EAAaQ,UAC/B8I,EAAImC,UAAYxI,KAAK6B,SAAW,GAAM,EAEtC,IAAK,IAAI2D,EAAI,EAAGA,EAAItG,EAAYC,SAAUqG,IAAK,CAC7C,MAAMiD,EAAMjD,EAAIxF,KAAKwD,SACrB6C,EAAIG,YACJH,EAAIqC,OAAOD,EAAK,GAChBpC,EAAIsC,OAAOF,EAAKzI,KAAKuD,WAAWqB,QAChCyB,EAAIuC,SACJvC,EAAIG,YACJH,EAAIqC,OAAO,EAAGD,GACdpC,EAAIsC,OAAO3I,KAAKuD,WAAWoB,MAAO8D,GAClCpC,EAAIuC,QACN,CACF,CAEAC,cAAAA,GAEE7I,KAAKiB,MAAMhE,MAAQ+C,KAAKiB,MAAMhE,MAAM6L,KAAI/D,IAAO,CAC7C3C,EAAG0B,KAAKiF,MAAMhE,EAAQ3C,EAAIpC,KAAKwD,UAAYxD,KAAKwD,SAChDnB,EAAGyB,KAAKiF,MAAMhE,EAAQ1C,EAAIrC,KAAKwD,UAAYxD,KAAKwD,aAG9CxD,KAAKiB,MAAM5D,OACb2C,KAAKiB,MAAM5D,KAAO,CAChB+E,EAAG0B,KAAKiF,MAAM/I,KAAKiB,MAAM5D,KAAK+E,EAAIpC,KAAKwD,UAAYxD,KAAKwD,SACxDnB,EAAGyB,KAAKiF,MAAM/I,KAAKiB,MAAM5D,KAAKgF,EAAIrC,KAAKwD,UAAYxD,KAAKwD,WAK5DxD,KAAKgJ,cACP,CAEAA,YAAAA,GACE,MAAMC,EAAOjJ,KAAKuD,WAAWoB,MAAQ3E,KAAKwD,SACpC0F,EAAOlJ,KAAKuD,WAAWqB,OAAS5E,KAAKwD,SAG3CxD,KAAKiB,MAAMhE,MAAQ+C,KAAKiB,MAAMhE,MAAM6L,KAAI/D,IAAO,CAC7C3C,EAAG0B,KAAKqF,IAAI,EAAGrF,KAAKsF,IAAIrE,EAAQ3C,EAAG6G,IACnC5G,EAAGyB,KAAKqF,IAAI,EAAGrF,KAAKsF,IAAIrE,EAAQ1C,EAAG6G,QAIjClJ,KAAKiB,MAAM5D,OACb2C,KAAKiB,MAAM5D,KAAO,CAChB+E,EAAG0B,KAAKqF,IAAI,EAAGrF,KAAKsF,IAAIpJ,KAAKiB,MAAM5D,KAAK+E,EAAG6G,IAC3C5G,EAAGyB,KAAKqF,IAAI,EAAGrF,KAAKsF,IAAIpJ,KAAKiB,MAAM5D,KAAKgF,EAAG6G,KAGjD,CAEAtF,mBAAAA,GACE,CAGFyF,OAAAA,GAEMrJ,KAAKqD,kBACPkB,SAAS+E,oBAAoB,UAAWtJ,KAAKqD,iBAC7CrD,KAAKqD,gBAAkB,MAIzBrD,KAAKiB,MAAQ,CACXhE,MAAO,GACPI,KAAM,KACN8E,UAAW,CAAEC,EAAG,EAAGC,EAAG,GACtBC,cAAe,CAAEF,EAAG,EAAGC,EAAG,GAC1BE,MAAO,EACP9E,UAAU,EACV+E,WAAY,GAIdxC,KAAKyC,UAAY,GAGbzC,KAAKsG,MAAQtG,KAAKsG,KAAKC,SAAWvG,KAAKuD,YACzCvD,KAAKsG,KAAKC,QAAQgB,UAAU,EAAG,EAAGvH,KAAKuD,WAAWoB,MAAO3E,KAAKuD,WAAWqB,QAIvE5E,KAAKsG,MAAQtG,KAAKsG,KAAKiD,mBACzBC,qBAAqBxJ,KAAKsG,KAAKiD,kBAC/BvJ,KAAKsG,KAAKiD,iBAAmB,KAEjC,E,uBCjaF,MA4PA,EA5PkBE,KAChB,MAAMC,GAAeC,EAAAA,EAAAA,QAAO,MACtBC,GAAYD,EAAAA,EAAAA,QAAO,MACnBE,GAAkBF,EAAAA,EAAAA,QAAO,MACzBG,GAAmBH,EAAAA,EAAAA,QAAO,OACzBI,EAAYC,IAAiBC,EAAAA,EAAAA,WAAS,IACtC1H,EAAO2H,IAAYD,EAAAA,EAAAA,UAAS,IAC5BtM,EAAWwM,IAAgBF,EAAAA,EAAAA,UAChCnH,SAASC,aAAaC,QAAQ,oBAAsB,IAE/CO,EAAY6G,IAAiBH,EAAAA,EAAAA,UAAS,CAAEtF,MAAO,EAAGC,OAAQ,KAC1D/C,EAAUwI,IAAeJ,EAAAA,EAAAA,WAAS,GACnCK,GAAgBX,EAAAA,EAAAA,QAAO,CAAEvH,EAAG,EAAGC,EAAG,EAAGyE,KAAM,IAE3CyD,GAAeC,EAAAA,EAAAA,cAAY,KAC3BV,EAAiBW,SACnBC,aAAaZ,EAAiBW,SAGhCX,EAAiBW,QAAUE,YAAW,KACpC,GAAIjB,EAAae,QACf,IACE,MAAMG,EAAYlB,EAAae,SACzB,MAAE9F,EAAK,OAAEC,GAAWgG,EAAUC,wBAC9BC,EH+CaC,EAACC,EAAgBC,KAC5C,MAAM,YAAErN,EAAW,YAAEC,GAAgBd,GAC/B,SAAEoC,GAAaD,EAGfgM,EAAsBpH,KAAKsF,IAC/BtF,KAAKC,MAAMiH,EAAiB7L,GAC5B2E,KAAKC,MAAMkH,EAAkB9L,IAIzBqE,EAAWM,KAAKqF,IACpBvL,EACAkG,KAAKsF,IAAI8B,EAAqBrN,IAIhC,MAAO,CACL8G,MAAOnB,EAAWrE,EAClByF,OAAQpB,EAAWrE,EACnBqE,SAAUA,EACX,EGpEuBuH,CAAcpG,EAAOC,GAGjCkG,EAAQnG,QAAUpB,EAAWoB,OAASmG,EAAQlG,SAAWrB,EAAWqB,SACtEwF,EAAcU,GACdT,EAAY1F,GAAS1F,GAGjB2K,EAAUa,UACZb,EAAUa,QAAQ9F,MAAQmG,EAAQnG,MAClCiF,EAAUa,QAAQ7F,OAASkG,EAAQlG,QAIjCiF,EAAgBY,UAClBZ,EAAgBY,QAAQlH,WAAauH,EACrCjB,EAAgBY,QAAQ5B,kBAG9B,CAAE,MAAOzH,GACPF,QAAQE,MAAM,uBAAwBA,EACxC,CACF,GACC,IAAI,GACN,CAACmC,KAEJ4H,EAAAA,EAAAA,YAAU,KAGR,IAAIC,EAFJb,IAGA,IACEa,EAAiB,IAAIC,gBAAgBC,IAEnC,MAAMC,EAAQD,EAAQ,GAClBC,GAASA,EAAMC,aACjBjB,GACF,IAGEb,EAAae,SACfW,EAAeK,QAAQ/B,EAAae,QAExC,CAAE,MAAOrJ,GACPF,QAAQG,KAAK,wBAAyBD,EACxC,CAKA,OAHAsK,OAAOlH,iBAAiB,SAAU+F,GAClCmB,OAAOlH,iBAAiB,oBAAqB+F,GAEtC,KACDT,EAAiBW,SACnBC,aAAaZ,EAAiBW,SAE5BW,GACFA,EAAeO,aAEjBD,OAAOpC,oBAAoB,SAAUiB,GACrCmB,OAAOpC,oBAAoB,oBAAqBiB,EAAa,CAC9D,GACA,CAACA,KAEJY,EAAAA,EAAAA,YAAU,KACR,GAAIvB,EAAUa,SAAWf,EAAae,SAAWlH,EAAWoB,OAASpB,EAAWqB,OAAQ,CACtF,MAAMgH,EAAShC,EAAUa,QACnBpE,EAAMuF,EAAOC,WAAW,MAG9BD,EAAOjH,MAAQpB,EAAWoB,MAC1BiH,EAAOhH,OAASrB,EAAWqB,OAG3B,MAAM0B,EAAO,IAAI3E,EAAWE,GAU5B,IAAI0H,EATJjD,EAAKA,KAAO,CAAEC,QAASF,EAAKuF,UAC5BtF,EAAKhD,OAAOC,GACZsG,EAAgBY,QAAUnE,EAG1BsF,EAAOE,aAAa,WAAY,KAChCF,EAAOG,QAIP,MAAMC,EAAUlF,IACTR,EAAKrF,MAAMxD,WACd6I,EAAKO,OAAOC,GACZoD,EAAS5D,EAAKrF,MAAMsB,OAChB+D,EAAKrF,MAAMxD,WACbuM,GAAc,GACV1D,EAAKrF,MAAMsB,MAAQ5E,IACrBwM,EAAa7D,EAAKrF,MAAMsB,OACxBQ,aAAaqE,QAAQ,iBAAkBd,EAAKrF,MAAMsB,SAGtDgH,EAAmBmC,OAAOO,sBAAsBD,GAClD,EAKF,OAHAA,EAAO,GAGA,KACLN,OAAOlC,qBAAqBD,GACxBjD,EAAK+C,SACP/C,EAAK+C,UAEPQ,EAAgBY,QAAU,IAAI,CAElC,IACC,CAAClH,EAAY1B,EAAUlE,IAE1B,MAAMuO,GAAgB1B,EAAAA,EAAAA,cAAY,KAC5BX,EAAgBY,UAClBZ,EAAgBY,QAAQ/G,iBACxBsG,GAAc,GACdE,EAAS,GACLN,EAAUa,SACZb,EAAUa,QAAQsB,QAEtB,GACC,IAoCH,OACEI,EAAAA,EAAAA,KAACC,EAAAA,EAAiB,CAAAC,UAChBF,EAAAA,EAAAA,KAAA,OAAKG,IAAK5C,EAAc6C,UAAU,aAAYF,UAC5CG,EAAAA,EAAAA,MAAA,OAAKD,UAAU,iBAAgBF,SAAA,EAC7BG,EAAAA,EAAAA,MAAA,OAAKD,UAAU,gBAAeF,SAAA,EAC5BG,EAAAA,EAAAA,MAAA,OAAKD,UAAU,QAAOF,SAAA,EACpBF,EAAAA,EAAAA,KAAA,QAAAE,SAAM,WACNF,EAAAA,EAAAA,KAAA,QAAAE,SAAOI,OAAOlK,GAAOmK,SAAS,EAAG,WAEnCF,EAAAA,EAAAA,MAAA,OAAKD,UAAU,aAAYF,SAAA,EACzBF,EAAAA,EAAAA,KAAA,QAAAE,SAAM,UACNF,EAAAA,EAAAA,KAAA,QAAAE,SAAOI,OAAO9O,GAAW+O,SAAS,EAAG,UAEtCnK,EAAQ,GAAKA,GAAS5E,IACrB6O,EAAAA,EAAAA,MAAA,OAAKD,UAAU,gBAAeF,SAAA,EAC5BF,EAAAA,EAAAA,KAAA,OAAKhJ,IAAKC,EAAUuJ,IAAI,aACxBR,EAAAA,EAAAA,KAAA,OAAKI,UAAU,cAAaF,SAAC,qBAInCF,EAAAA,EAAAA,KAAA,UACEG,IAAK1C,EACL2C,UAAU,cACVK,aAzDgBC,IACxB,MAAMC,EAAQD,EAAEE,QAAQ,GACxBzC,EAAcG,QAAU,CACtBrI,EAAG0K,EAAME,QACT3K,EAAGyK,EAAMG,QACTnG,KAAMoG,KAAKzL,MACZ,EAoDO0L,WAjDcN,IACtB,MAAMC,EAAQD,EAAEO,eAAe,GACzBC,EAASP,EAAME,QAAU1C,EAAcG,QAAQrI,EAC/CkL,EAASR,EAAMG,QAAU3C,EAAcG,QAAQpI,EAGrD,GAFkB6K,KAAKzL,MAAQ6I,EAAcG,QAAQ3D,KAErC5H,EAAYqO,eAAezG,KAAM,CAE/C,GADiBhD,KAAK0J,KAAKH,EAASA,EAASC,EAASA,GACvCpO,EAAYqO,eAAeE,SAAU,CAClD,MAAMhI,EAAQ3B,KAAK4J,MAAMJ,EAAQD,GAC3BlL,EAAY2B,KAAKiF,MAAMtD,GAAS3B,KAAK4B,GAAK,IAEhD,GAAImE,EAAgBY,QAClB,QAAUtI,EAAY,GAAK,GACzB,KAAK,EAAG0H,EAAgBY,QAAQkD,aAAa,SAAU,MACvD,KAAK,EAAG9D,EAAgBY,QAAQkD,aAAa,QAAS,MACtD,KAAK,EAAG9D,EAAgBY,QAAQkD,aAAa,QAAS,MACtD,KAAK,EAAG9D,EAAgBY,QAAQkD,aAAa,MAInD,CACF,KA6BO5D,IACCoC,EAAAA,EAAAA,KAAA,OAAKI,UAAU,YAAWF,UACxBG,EAAAA,EAAAA,MAAA,OAAKD,UAAU,oBAAmBF,SAAA,EAChCG,EAAAA,EAAAA,MAAA,OAAKD,UAAU,oBAAmBF,SAAA,EAChCF,EAAAA,EAAAA,KAAA,OAAKhJ,IAAKC,EAAUuJ,IAAI,UAAUJ,UAAU,mBAC5CJ,EAAAA,EAAAA,KAAA,OAAKI,UAAU,sBAEjBJ,EAAAA,EAAAA,KAAA,MAAI,YAAU,YAAWE,SAAC,eAC1BF,EAAAA,EAAAA,KAAA,OAAKI,UAAU,gBAAeF,SAC3B9J,IAAU5E,GAAa4E,EAAQ,GAC9BiK,EAAAA,EAAAA,MAAAoB,EAAAA,SAAA,CAAAvB,SAAA,EACEG,EAAAA,EAAAA,MAAA,OAAKD,UAAU,eAAcF,SAAA,EAC3BF,EAAAA,EAAAA,KAAA,QAAMI,UAAU,OAAMF,SAAC,YACvBF,EAAAA,EAAAA,KAAA,QAAMI,UAAU,aAAYF,SAAC,iBAC7BF,EAAAA,EAAAA,KAAA,QAAMI,UAAU,OAAMF,SAAC,eAEzBG,EAAAA,EAAAA,MAAA,KAAGD,UAAU,cAAaF,SAAA,CAAC,UAAQI,OAAOlK,GAAOmK,SAAS,EAAG,SAC7DP,EAAAA,EAAAA,KAAA,KAAGI,UAAU,mBAAkBF,SAAC,4BAGlCG,EAAAA,EAAAA,MAAAoB,EAAAA,SAAA,CAAAvB,SAAA,EACEG,EAAAA,EAAAA,MAAA,KAAGD,UAAU,cAAaF,SAAA,CAAC,UAAQI,OAAOlK,GAAOmK,SAAS,EAAG,SAC7DF,EAAAA,EAAAA,MAAA,KAAGD,UAAU,mBAAkBF,SAAA,CAAC,SAAOI,OAAO9O,GAAW+O,SAAS,EAAG,SACrEP,EAAAA,EAAAA,KAAA,KAAGI,UAAU,mBAAkBF,SAClB,IAAV9J,EAAc,iBACdA,EAAQ,EAAI,qBACZA,EAAQ,GAAK,kBACbA,EAAQ5E,EAAY,gBACpB,qBAKTwO,EAAAA,EAAAA,KAAA,OAAKI,UAAU,oBAAmBF,UAChCG,EAAAA,EAAAA,MAAA,UAAQqB,QAAS3B,EAAeK,UAAU,iBAAgBF,SAAA,EACxDF,EAAAA,EAAAA,KAAA,QAAMI,UAAU,WAAUF,SAAC,gBAC3BF,EAAAA,EAAAA,KAAA,QAAMI,UAAU,WAAUF,SAAC,2BAQvB,C","sources":["components/Tools/snake/constants.js","components/Tools/snake/sounds.js","components/Tools/snake/snake.js","components/Tools/snake/index.js"],"sourcesContent":["// Theme configuration\nexport const THEME = {\n  colors: {\n    background: \"rgba(10, 10, 15, 0.8)\", // Darker, more opaque background\n    snake: {\n      gradient: [\"#7AA2F7\", \"#7DCFFF\", \"#2AC3DE\"], // Cool blue gradient\n      glow: \"#7AA2F7\", // Matching glow color\n    },\n    snakeHead: {\n      gradient: [\"#BB9AF7\", \"#9D7CD8\"], // Purple gradient\n      glow: \"#BB9AF7\", // Matching glow color\n    },\n    food: {\n      gradient: [\"#F7768E\", \"#FF9E64\"], // Warm gradient\n      glow: \"#F7768E\", // Matching glow color\n    },\n    border: \"#24283B\", // Subtle border\n    gridLines: \"rgba(255, 255, 255, 0.05)\", // Subtle grid lines\n    text: \"#A9B1D6\", // Soft text color\n    gameOver: \"#F7768E\", // Warm red for game over\n    scoreBackground: \"rgba(26, 27, 38, 0.9)\", // Dark score background\n    highScore: \"#9ECE6A\", // Green for high score\n  },\n\n  dimensions: {\n    minTileSize: 20, // Minimum size for each grid cell\n    maxTileSize: 32, // Maximum size for each grid cell\n    borderRadius: 4, // Rounded corners for tiles\n    gridLineWidth: 1,\n    shadowBlur: 30,\n    glowRadius: 40,\n    innerShadowSize: 10,\n  },\n\n  animations: {\n    snakeSpeed: {\n      mobile: 100,\n      desktop: 80,\n    },\n    fadeSpeed: 400, // Smooth fade transitions\n    growthFactor: 1.15, // More pronounced growth\n    foodPulseSpeed: 1800, // Slower pulse for food\n    foodPulseScale: 1.18, // Larger pulse scale\n    snakeGlowIntensity: 0.8, // Increased glow intensity\n    shadowPulseSpeed: 200, // Speed of shadow pulse\n    particleCount: 10,\n    particleLifetime: 1000,\n    particleGravity: 0.1,\n    particleSpeed: 2,\n    particleSize: 0.5,\n  },\n};\n\n// Responsive configuration\nexport const RESPONSIVE_CONFIG = {\n  mobileBreakpoint: 768, // Width threshold for mobile devices\n  touchMinDistance: 30, // Minimum swipe distance to trigger direction change\n  touchMaxTime: 300, // Maximum time for a swipe gesture\n  resizeDebounce: 250, // Debounce time for resize events\n};\n\n// Game configuration\nexport const GAME_CONFIG = {\n  gridSize: 20, // Number of cells in both width and height\n  initialSnakeLength: 3,\n  growthRate: 1,\n  maxHighScores: 5,\n  controls: {\n    up: [\"ArrowUp\", \"w\", \"W\"],\n    down: [\"ArrowDown\", \"s\", \"S\"],\n    left: [\"ArrowLeft\", \"a\", \"A\"],\n    right: [\"ArrowRight\", \"d\", \"D\"],\n    pause: [\"Space\", \"p\", \"P\"],\n    restart: [\"r\", \"R\"],\n  },\n};\n\n// Helper functions\nexport const getCanvasSize = (containerWidth, containerHeight) => {\n  const { minTileSize, maxTileSize } = THEME.dimensions;\n  const { gridSize } = GAME_CONFIG;\n\n  // Calculate the maximum possible cell size that fits in both dimensions\n  const maxPossibleCellSize = Math.min(\n    Math.floor(containerWidth / gridSize),\n    Math.floor(containerHeight / gridSize)\n  );\n\n  // Clamp the cell size between min and max\n  const cellSize = Math.max(\n    minTileSize,\n    Math.min(maxPossibleCellSize, maxTileSize)\n  );\n\n  // Calculate the final canvas size to ensure perfect squares\n  return {\n    width: cellSize * gridSize,\n    height: cellSize * gridSize,\n    cellSize: cellSize,\n  };\n};\n\nexport const getCellSize = (canvasSize) => {\n  return canvasSize.cellSize;\n};\n","import * as Tone from 'tone';\n\nclass SoundManager {\n    constructor() {\n        // Initialize synths\n        this.foodSynth = new Tone.Synth({\n            oscillator: {\n                type: \"sine\"\n            },\n            envelope: {\n                attack: 0.01,\n                decay: 0.1,\n                sustain: 0,\n                release: 0.1\n            }\n        }).toDestination();\n\n        this.gameOverSynth = new Tone.PolySynth(Tone.Synth, {\n            oscillator: {\n                type: \"triangle\"\n            },\n            envelope: {\n                attack: 0.01,\n                decay: 0.3,\n                sustain: 0,\n                release: 0.1\n            }\n        }).toDestination();\n\n        this.moveSynth = new Tone.Synth({\n            oscillator: {\n                type: \"square\"\n            },\n            envelope: {\n                attack: 0.01,\n                decay: 0.05,\n                sustain: 0,\n                release: 0.05\n            },\n            volume: -20\n        }).toDestination();\n\n        // Initialize effects\n        this.feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\n        this.gameOverSynth.connect(this.feedbackDelay);\n    }\n\n    async initialize() {\n        // Only initialize if context is not running\n        if (Tone.context.state !== 'running') {\n            try {\n                await Tone.start();\n                console.log('Audio context started');\n            } catch (error) {\n                console.warn('Could not start audio context:', error);\n            }\n        }\n    }\n\n    playFoodCollect() {\n        this.foodSynth.triggerAttackRelease(\"C5\", \"16n\");\n    }\n\n    playGameOver() {\n        // Play a descending pattern\n        const now = Tone.now();\n        this.gameOverSynth.triggerAttackRelease([\"C4\", \"G3\", \"E3\", \"C3\"], \"8n\", now);\n    }\n\n    playMove() {\n        this.moveSynth.triggerAttackRelease(\"G4\", \"32n\");\n    }\n}\n\n// Create and export a singleton instance\nconst soundManager = new SoundManager();\nexport { soundManager };\n","// External dependencies\nimport { Scene } from 'phaser';\nimport { \n  THEME, \n  GAME_CONFIG\n} from './constants';\nimport profile1 from '../../../assets/images/profile1-nbg.png';\nimport { soundManager as sound } from './sounds';\n\nexport class SnakeScene extends Scene {\n  constructor(isMobile = false) {\n    super({ key: 'SnakeScene' });\n    this.state = {\n      snake: [],\n      food: null,\n      direction: { x: 0, y: 0 },\n      nextDirection: { x: 0, y: 0 },\n      score: 0,\n      gameOver: false,\n      lastUpdate: 0\n    };\n    this.particles = [];\n    this.currentHue = 0;\n    this.snakeHue = 180; // Starting color for snake\n    this.foodHue = 0;    // Starting color for food\n    this.isMobile = isMobile;\n    this.gameSpeed = isMobile ? THEME.animations.snakeSpeed.mobile : THEME.animations.snakeSpeed.desktop;\n    this.highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;\n    this.avatar = new Image();\n    this.avatar.src = profile1;\n    this.boundKeyHandler = null;\n  }\n\n  async create(canvasSize) {\n    this.canvasSize = canvasSize;\n    this.cellSize = canvasSize.cellSize; // Use the precalculated cell size\n    await sound.initialize();\n    this.initializeGame();\n    this.setupInput();\n    this.setupEventListeners();\n  }\n\n  initializeGame() {\n    const centerX = Math.floor(GAME_CONFIG.gridSize / 2) * this.cellSize;\n    const centerY = Math.floor(GAME_CONFIG.gridSize / 2) * this.cellSize;\n    \n    this.state.snake = [{ x: centerX, y: centerY }];\n    this.state.direction = { x: this.cellSize, y: 0 };\n    this.state.nextDirection = { x: this.cellSize, y: 0 };\n    this.spawnFood();\n    this.state.score = 0;\n    this.state.gameOver = false;\n  }\n\n  setupInput() {\n    this.boundKeyHandler = (event) => {\n      this.handleKeyPress(event.code);\n      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {\n        event.preventDefault();\n      }\n    };\n    document.addEventListener('keydown', this.boundKeyHandler);\n  }\n\n  handleKeyPress(key) {\n    if (this.state.gameOver) {\n      if (key === 'Space' || key === 'Enter') {\n        this.initializeGame();\n        return;\n      }\n    }\n\n    const { direction } = this.state;\n    const cellSize = this.cellSize;\n    \n    switch(key) {\n      case 'ArrowUp':\n        if (direction.y === 0) {\n          this.state.nextDirection = { x: 0, y: -cellSize };\n        }\n        break;\n      case 'ArrowDown':\n        if (direction.y === 0) {\n          this.state.nextDirection = { x: 0, y: cellSize };\n        }\n        break;\n      case 'ArrowLeft':\n        if (direction.x === 0) {\n          this.state.nextDirection = { x: -cellSize, y: 0 };\n        }\n        break;\n      case 'ArrowRight':\n        if (direction.x === 0) {\n          this.state.nextDirection = { x: cellSize, y: 0 };\n        }\n        break;\n      case 'Space':\n      case 'Enter':\n        if (this.state.gameOver) {\n          this.initializeGame();\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  generateFoodPosition() {\n    const x = Math.floor(Math.random() * (this.canvasSize.width / this.cellSize)) * this.cellSize;\n    const y = Math.floor(Math.random() * (this.canvasSize.height / this.cellSize)) * this.cellSize;\n    return { x, y };\n  }\n\n  isValidFoodPosition(food) {\n    return !this.state.snake.some(segment => this.isCollision(segment, food));\n  }\n\n  spawnFood() {\n    let newFood;\n    do {\n      newFood = this.generateFoodPosition();\n    } while (!this.isValidFoodPosition(newFood));\n    \n    this.state.food = newFood;\n  }\n\n  isCollision(pos1, pos2) {\n    const tolerance = this.cellSize / 4; // Add some tolerance for collision detection\n    return Math.abs(pos1.x - pos2.x) < tolerance && Math.abs(pos1.y - pos2.y) < tolerance;\n  }\n\n  createParticles() {\n    const { food } = this.state;\n    const particleCount = 10;\n    const baseHue = this.foodHue; // Use current food hue for particles\n    \n    for (let i = 0; i < particleCount; i++) {\n      const angle = (Math.PI * 2 * i) / particleCount;\n      const speed = 2 + Math.random() * 2;\n      const size = 2 + Math.random() * 3;\n      \n      this.particles.push({\n        x: food.x + this.cellSize / 2,\n        y: food.y + this.cellSize / 2,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size,\n        life: 1,\n        hue: (baseHue + Math.random() * 30) % 360,\n        draw: function() {\n          if (this.life <= 0) return;\n          \n          const ctx = this.game.context;\n          ctx.beginPath();\n          ctx.fillStyle = `hsla(${this.hue}, 70%, 50%, ${this.life})`;\n          ctx.shadowColor = `hsla(${this.hue}, 80%, 60%, ${this.life})`;\n          ctx.shadowBlur = 5;\n          ctx.fillRect(this.x, this.y, this.size, this.size);\n          ctx.shadowBlur = 0;\n          \n          // Update position and life\n          this.x += this.vx;\n          this.y += this.vy;\n          this.life -= 0.05;\n        }.bind(this)\n      });\n    }\n  }\n\n  update(time) {\n    if (this.state.gameOver) {\n      return;\n    }\n\n    // Update colors\n    this.snakeHue = (this.snakeHue + 0.5) % 360;\n    this.foodHue = (this.foodHue + 1) % 360;\n\n    // Check if enough time has passed since last update\n    if (time - this.state.lastUpdate < this.gameSpeed) {\n      return;\n    }\n    \n    this.state.lastUpdate = time;\n    this.moveSnake();\n    if (this.checkCollisions()) {\n      return;\n    }\n    this.draw();\n    this.updateParticles();\n  }\n\n  checkCollisions() {\n    const { snake } = this.state;\n    const head = snake[0];\n    \n    // Check self collision\n    for (let i = 1; i < snake.length; i++) {\n      if (this.isCollision(head, snake[i])) {\n        this.state.gameOver = true;\n        sound.playGameOver();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  moveSnake() {\n    const { snake, nextDirection, food } = this.state;\n    const head = { ...snake[0] };\n    \n    this.state.direction = nextDirection;\n    head.x += nextDirection.x;\n    head.y += nextDirection.y;\n\n    // Wrap around walls\n    const width = this.canvasSize.width;\n    const height = this.canvasSize.height;\n    \n    if (head.x >= width) head.x = 0;\n    if (head.x < 0) head.x = width - this.cellSize;\n    if (head.y >= height) head.y = 0;\n    if (head.y < 0) head.y = height - this.cellSize;\n\n    snake.unshift(head);\n    \n    // Check food collision\n    if (this.isCollision(head, food)) {\n      // Play food collection sound\n      sound.playFoodCollect();\n      \n      // Increment score\n      this.state.score++;\n      \n      // Create particles\n      this.createParticles();\n      \n      // Spawn new food\n      this.spawnFood();\n      \n      // Update high score\n      if (this.state.score > this.highScore) {\n        this.highScore = this.state.score;\n        localStorage.setItem('snakeHighScore', this.state.score);\n      }\n      \n      // Don't remove tail to grow snake\n    } else {\n      // Remove tail if no food was eaten\n      snake.pop();\n    }\n  }\n\n  updateParticles() {\n    for (let i = this.particles.length - 1; i >= 0; i--) {\n      this.particles[i].draw();\n      if (this.particles[i].life <= 0) {\n        this.particles.splice(i, 1);\n      }\n    }\n  }\n\n  draw() {\n    const { snake, food } = this.state;\n    const ctx = this.game.context;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, this.canvasSize.width, this.canvasSize.height);\n    \n    // Draw grid\n    this.drawGrid();\n    \n    // Draw snake with color cycling\n    snake.forEach((segment, index) => {\n      const isHead = index === 0;\n      ctx.beginPath();\n      \n      // Create gradient based on position in snake\n      const segmentHue = (this.snakeHue + (index * 5)) % 360;\n      const baseColor = `hsl(${segmentHue}, 70%, ${isHead ? 60 : 50}%)`;\n      const glowColor = `hsl(${segmentHue}, 80%, 60%)`;\n      \n      ctx.fillStyle = baseColor;\n      ctx.shadowColor = glowColor;\n      ctx.shadowBlur = isHead ? 15 : 10;\n      ctx.fillRect(segment.x, segment.y, this.cellSize - 1, this.cellSize - 1);\n    });\n    ctx.shadowBlur = 0;\n    \n    // Draw food if it exists\n    if (food) {\n      ctx.save();\n      \n      // Create color overlay\n      const foodColor = `hsl(${this.foodHue}, 70%, 50%)`;\n      const foodGlow = `hsl(${this.foodHue}, 80%, 60%)`;\n      \n      // Add glow effect\n      ctx.shadowColor = foodGlow;\n      ctx.shadowBlur = 15;\n      \n      // Draw the avatar image\n      ctx.drawImage(\n        this.avatar,\n        food.x,\n        food.y,\n        this.cellSize - 1,\n        this.cellSize - 1\n      );\n      \n      // Add colored overlay\n      ctx.globalCompositeOperation = 'overlay';\n      ctx.fillStyle = foodColor;\n      ctx.fillRect(food.x, food.y, this.cellSize - 1, this.cellSize - 1);\n      \n      // Add pixelation effect\n      ctx.globalCompositeOperation = 'source-over';\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';\n      const pixelSize = 2;\n      for (let x = 0; x < this.cellSize - 1; x += pixelSize) {\n        for (let y = 0; y < this.cellSize - 1; y += pixelSize) {\n          if ((x + y) % 4 === 0) {\n            ctx.fillRect(food.x + x, food.y + y, pixelSize, pixelSize);\n          }\n        }\n      }\n      \n      ctx.restore();\n    }\n    \n    // Draw particles\n    this.particles.forEach(particle => particle.draw());\n  }\n\n  drawGrid() {\n    const ctx = this.game.context;\n    ctx.strokeStyle = THEME.colors.gridLines;\n    ctx.lineWidth = this.isMobile ? 0.5 : 1;\n    \n    for (let i = 0; i < GAME_CONFIG.gridSize; i++) {\n      const pos = i * this.cellSize;\n      ctx.beginPath();\n      ctx.moveTo(pos, 0);\n      ctx.lineTo(pos, this.canvasSize.height);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(0, pos);\n      ctx.lineTo(this.canvasSize.width, pos);\n      ctx.stroke();\n    }\n  }\n\n  updateGridSize() {\n    // Recalculate positions based on new cell size\n    this.state.snake = this.state.snake.map(segment => ({\n      x: Math.round(segment.x / this.cellSize) * this.cellSize,\n      y: Math.round(segment.y / this.cellSize) * this.cellSize\n    }));\n\n    if (this.state.food) {\n      this.state.food = {\n        x: Math.round(this.state.food.x / this.cellSize) * this.cellSize,\n        y: Math.round(this.state.food.y / this.cellSize) * this.cellSize\n      };\n    }\n\n    // Ensure snake and food are within bounds\n    this.keepInBounds();\n  }\n\n  keepInBounds() {\n    const maxX = this.canvasSize.width - this.cellSize;\n    const maxY = this.canvasSize.height - this.cellSize;\n\n    // Adjust snake segments\n    this.state.snake = this.state.snake.map(segment => ({\n      x: Math.max(0, Math.min(segment.x, maxX)),\n      y: Math.max(0, Math.min(segment.y, maxY))\n    }));\n\n    // Adjust food if it exists\n    if (this.state.food) {\n      this.state.food = {\n        x: Math.max(0, Math.min(this.state.food.x, maxX)),\n        y: Math.max(0, Math.min(this.state.food.y, maxY))\n      };\n    }\n  }\n\n  setupEventListeners() {\n    // Removed keyboard listener setup\n  }\n\n  cleanup() {\n    // Remove keyboard event listeners\n    if (this.boundKeyHandler) {\n      document.removeEventListener('keydown', this.boundKeyHandler);\n      this.boundKeyHandler = null;\n    }\n\n    // Clear game state\n    this.state = {\n      snake: [],\n      food: null,\n      direction: { x: 0, y: 0 },\n      nextDirection: { x: 0, y: 0 },\n      score: 0,\n      gameOver: false,\n      lastUpdate: 0\n    };\n\n    // Clear particles\n    this.particles = [];\n\n    // Clear canvas if it exists\n    if (this.game && this.game.context && this.canvasSize) {\n      this.game.context.clearRect(0, 0, this.canvasSize.width, this.canvasSize.height);\n    }\n\n    // Stop any ongoing animations\n    if (this.game && this.game.animationFrameId) {\n      cancelAnimationFrame(this.game.animationFrameId);\n      this.game.animationFrameId = null;\n    }\n  }\n}","import React, { useEffect, useRef, useState, useCallback } from 'react';\nimport { getCanvasSize, RESPONSIVE_CONFIG, GAME_CONFIG } from './constants';\nimport { SnakeScene } from './snake';\nimport FullscreenWrapper from '../FullscreenWrapper';\nimport profile1 from '../../../assets/images/profile1-nbg.png';\nimport './snake.scss';\n\nconst SnakeGame = () => {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const gameInstanceRef = useRef(null);\n  const resizeTimeoutRef = useRef(null);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState(0);\n  const [highScore, setHighScore] = useState(\n    parseInt(localStorage.getItem('snakeHighScore')) || 0\n  );\n  const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 });\n  const [isMobile, setIsMobile] = useState(false);\n  const touchStartRef = useRef({ x: 0, y: 0, time: 0 });\n\n  const handleResize = useCallback(() => {\n    if (resizeTimeoutRef.current) {\n      clearTimeout(resizeTimeoutRef.current);\n    }\n\n    resizeTimeoutRef.current = setTimeout(() => {\n      if (containerRef.current) {\n        try {\n          const container = containerRef.current;\n          const { width, height } = container.getBoundingClientRect();\n          const newSize = getCanvasSize(width, height);\n          \n          // Only update if size actually changed\n          if (newSize.width !== canvasSize.width || newSize.height !== canvasSize.height) {\n            setCanvasSize(newSize);\n            setIsMobile(width <= RESPONSIVE_CONFIG.mobileBreakpoint);\n\n            // Update canvas size\n            if (canvasRef.current) {\n              canvasRef.current.width = newSize.width;\n              canvasRef.current.height = newSize.height;\n            }\n\n            // Update game instance\n            if (gameInstanceRef.current) {\n              gameInstanceRef.current.canvasSize = newSize;\n              gameInstanceRef.current.updateGridSize();\n            }\n          }\n        } catch (error) {\n          console.error('Error during resize:', error);\n        }\n      }\n    }, 250);\n  }, [canvasSize]);\n\n  useEffect(() => {\n    handleResize();\n    \n    let resizeObserver;\n    try {\n      resizeObserver = new ResizeObserver((entries) => {\n        // Avoid infinite loops by checking if size actually changed\n        const entry = entries[0];\n        if (entry && entry.contentRect) {\n          handleResize();\n        }\n      });\n\n      if (containerRef.current) {\n        resizeObserver.observe(containerRef.current);\n      }\n    } catch (error) {\n      console.warn('ResizeObserver error:', error);\n    }\n\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('orientationchange', handleResize);\n\n    return () => {\n      if (resizeTimeoutRef.current) {\n        clearTimeout(resizeTimeoutRef.current);\n      }\n      if (resizeObserver) {\n        resizeObserver.disconnect();\n      }\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('orientationchange', handleResize);\n    };\n  }, [handleResize]);\n\n  useEffect(() => {\n    if (canvasRef.current && containerRef.current && canvasSize.width && canvasSize.height) {\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext('2d');\n      \n      // Set canvas size\n      canvas.width = canvasSize.width;\n      canvas.height = canvasSize.height;\n      \n      // Initialize game\n      const game = new SnakeScene(isMobile);\n      game.game = { context: ctx, canvas };\n      game.create(canvasSize);\n      gameInstanceRef.current = game;\n\n      // Focus the canvas for keyboard input\n      canvas.setAttribute('tabindex', '0');\n      canvas.focus();\n\n      // Animation loop\n      let animationFrameId;\n      const render = (time) => {\n        if (!game.state.gameOver) {\n          game.update(time);\n          setScore(game.state.score);\n          if (game.state.gameOver) {\n            setIsGameOver(true);\n            if (game.state.score > highScore) {\n              setHighScore(game.state.score);\n              localStorage.setItem('snakeHighScore', game.state.score);\n            }\n          }\n          animationFrameId = window.requestAnimationFrame(render);\n        }\n      };\n      render(0);\n\n      // Cleanup\n      return () => {\n        window.cancelAnimationFrame(animationFrameId);\n        if (game.cleanup) {\n          game.cleanup();\n        }\n        gameInstanceRef.current = null;\n      };\n    }\n  }, [canvasSize, isMobile, highScore]);\n\n  const handleRestart = useCallback(() => {\n    if (gameInstanceRef.current) {\n      gameInstanceRef.current.initializeGame();\n      setIsGameOver(false);\n      setScore(0);\n      if (canvasRef.current) {\n        canvasRef.current.focus();\n      }\n    }\n  }, []);\n\n  const handleTouchStart = (e) => {\n    const touch = e.touches[0];\n    touchStartRef.current = {\n      x: touch.clientX,\n      y: touch.clientY,\n      time: Date.now()\n    };\n  };\n\n  const handleTouchEnd = (e) => {\n    const touch = e.changedTouches[0];\n    const deltaX = touch.clientX - touchStartRef.current.x;\n    const deltaY = touch.clientY - touchStartRef.current.y;\n    const deltaTime = Date.now() - touchStartRef.current.time;\n\n    if (deltaTime < GAME_CONFIG.touchThreshold.time) {\n      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n      if (distance > GAME_CONFIG.touchThreshold.distance) {\n        const angle = Math.atan2(deltaY, deltaX);\n        const direction = Math.round(angle / (Math.PI / 2));\n        \n        if (gameInstanceRef.current) {\n          switch (((direction + 4) % 4)) {\n            case 0: gameInstanceRef.current.setDirection('right'); break;\n            case 1: gameInstanceRef.current.setDirection('down'); break;\n            case 2: gameInstanceRef.current.setDirection('left'); break;\n            case 3: gameInstanceRef.current.setDirection('up'); break;\n            default: break;\n          }\n        }\n      }\n    }\n  };\n\n  return (\n    <FullscreenWrapper>\n      <div ref={containerRef} className=\"snake-tool\">\n        <div className=\"game-container\">\n          <div className=\"score-display\">\n            <div className=\"score\">\n              <span>Score</span>\n              <span>{String(score).padStart(2, '0')}</span>\n            </div>\n            <div className=\"high-score\">\n              <span>Best</span>\n              <span>{String(highScore).padStart(2, '0')}</span>\n            </div>\n            {score > 0 && score >= highScore && (\n              <div className=\"profile-badge\">\n                <img src={profile1} alt=\"Profile\" />\n                <div className=\"badge-label\">New Best!</div>\n              </div>\n            )}\n          </div>\n          <canvas\n            ref={canvasRef}\n            className=\"game-canvas\"\n            onTouchStart={handleTouchStart}\n            onTouchEnd={handleTouchEnd}\n          />\n          {isGameOver && (\n            <div className=\"game-over\">\n              <div className=\"game-over-content\">\n                <div className=\"profile-container\">\n                  <img src={profile1} alt=\"Profile\" className=\"profile-image\" />\n                  <div className=\"pixel-overlay\"></div>\n                </div>\n                <h2 data-text=\"GAME OVER\">GAME OVER</h2>\n                <div className=\"score-message\">\n                  {score === highScore && score > 0 ? (\n                    <>\n                      <div className=\"score-banner\">\n                        <span className=\"star\">★</span>\n                        <span className=\"new-record\">NEW RECORD!</span>\n                        <span className=\"star\">★</span>\n                      </div>\n                      <p className=\"score-value\">Score: {String(score).padStart(2, '0')}</p>\n                      <p className=\"encouraging-text\">You're unstoppable!</p>\n                    </>\n                  ) : (\n                    <>\n                      <p className=\"score-value\">Score: {String(score).padStart(2, '0')}</p>\n                      <p className=\"high-score-value\">Best: {String(highScore).padStart(2, '0')}</p>\n                      <p className=\"encouraging-text\">\n                        {score === 0 ? \"Don't give up!\" : \n                         score < 5 ? \"You can do better!\" :\n                         score < 10 ? \"Getting better!\" :\n                         score < highScore ? \"Almost there!\" :\n                         \"Great job!\"}\n                      </p>\n                    </>\n                  )}\n                </div>\n                <div className=\"game-over-buttons\">\n                  <button onClick={handleRestart} className=\"play-again-btn\">\n                    <span className=\"btn-text\">PLAY AGAIN</span>\n                    <span className=\"btn-icon\">↺</span>\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </FullscreenWrapper>\n  );\n};\n\nexport default SnakeGame;\n"],"names":["THEME","background","snake","gradient","glow","snakeHead","food","border","gridLines","text","gameOver","scoreBackground","highScore","minTileSize","maxTileSize","borderRadius","gridLineWidth","shadowBlur","glowRadius","innerShadowSize","snakeSpeed","mobile","desktop","fadeSpeed","growthFactor","foodPulseSpeed","foodPulseScale","snakeGlowIntensity","shadowPulseSpeed","particleCount","particleLifetime","particleGravity","particleSpeed","particleSize","RESPONSIVE_CONFIG","GAME_CONFIG","gridSize","initialSnakeLength","growthRate","maxHighScores","controls","up","down","left","right","pause","restart","soundManager","constructor","this","foodSynth","Tone","oscillator","type","envelope","attack","decay","sustain","release","toDestination","gameOverSynth","moveSynth","volume","feedbackDelay","connect","initialize","state","console","log","error","warn","playFoodCollect","triggerAttackRelease","playGameOver","now","playMove","SnakeScene","Scene","isMobile","arguments","length","undefined","super","key","direction","x","y","nextDirection","score","lastUpdate","particles","currentHue","snakeHue","foodHue","gameSpeed","parseInt","localStorage","getItem","avatar","Image","src","profile1","boundKeyHandler","create","canvasSize","cellSize","sound","initializeGame","setupInput","setupEventListeners","centerX","Math","floor","centerY","spawnFood","event","handleKeyPress","code","includes","preventDefault","document","addEventListener","generateFoodPosition","random","width","height","isValidFoodPosition","some","segment","isCollision","newFood","pos1","pos2","tolerance","abs","createParticles","baseHue","i","angle","PI","speed","size","push","vx","cos","vy","sin","life","hue","draw","ctx","game","context","beginPath","fillStyle","shadowColor","fillRect","bind","update","time","moveSnake","checkCollisions","updateParticles","head","unshift","setItem","pop","splice","clearRect","drawGrid","forEach","index","isHead","segmentHue","baseColor","glowColor","save","foodColor","foodGlow","drawImage","globalCompositeOperation","pixelSize","restore","particle","strokeStyle","lineWidth","pos","moveTo","lineTo","stroke","updateGridSize","map","round","keepInBounds","maxX","maxY","max","min","cleanup","removeEventListener","animationFrameId","cancelAnimationFrame","SnakeGame","containerRef","useRef","canvasRef","gameInstanceRef","resizeTimeoutRef","isGameOver","setIsGameOver","useState","setScore","setHighScore","setCanvasSize","setIsMobile","touchStartRef","handleResize","useCallback","current","clearTimeout","setTimeout","container","getBoundingClientRect","newSize","getCanvasSize","containerWidth","containerHeight","maxPossibleCellSize","useEffect","resizeObserver","ResizeObserver","entries","entry","contentRect","observe","window","disconnect","canvas","getContext","setAttribute","focus","render","requestAnimationFrame","handleRestart","_jsx","FullscreenWrapper","children","ref","className","_jsxs","String","padStart","alt","onTouchStart","e","touch","touches","clientX","clientY","Date","onTouchEnd","changedTouches","deltaX","deltaY","touchThreshold","sqrt","distance","atan2","setDirection","_Fragment","onClick"],"sourceRoot":""}