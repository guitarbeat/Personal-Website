{"version":3,"file":"static/js/658.fad28403.chunk.js","mappings":"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","sources":["components/Tools/snake/constants.js","components/Tools/snake/sounds.js","components/Tools/snake/snake.js","components/Tools/snake/index.js"],"sourcesContent":["// Theme configuration\nexport const THEME = {\n  colors: {\n    background: \"rgba(10, 10, 15, 0.8)\", // Darker, more opaque background\n    snake: {\n      gradient: [\"#7AA2F7\", \"#7DCFFF\", \"#2AC3DE\"], // Cool blue gradient\n      glow: \"#7AA2F7\", // Matching glow color\n    },\n    snakeHead: {\n      gradient: [\"#BB9AF7\", \"#9D7CD8\"], // Purple gradient\n      glow: \"#BB9AF7\", // Matching glow color\n    },\n    food: {\n      gradient: [\"#F7768E\", \"#FF9E64\"], // Warm gradient\n      glow: \"#F7768E\", // Matching glow color\n    },\n    border: \"#24283B\", // Subtle border\n    gridLines: \"rgba(255, 255, 255, 0.05)\", // Subtle grid lines\n    text: \"#A9B1D6\", // Soft text color\n    gameOver: \"#F7768E\", // Warm red for game over\n    scoreBackground: \"rgba(26, 27, 38, 0.9)\", // Dark score background\n    highScore: \"#9ECE6A\", // Green for high score\n  },\n\n  dimensions: {\n    minTileSize: 20, // Minimum size for each grid cell\n    maxTileSize: 32, // Maximum size for each grid cell\n    borderRadius: 4, // Rounded corners for tiles\n    gridLineWidth: 1,\n    shadowBlur: 30,\n    glowRadius: 40,\n    innerShadowSize: 10,\n  },\n\n  animations: {\n    snakeSpeed: {\n      mobile: 100,\n      desktop: 80,\n    },\n    fadeSpeed: 400, // Smooth fade transitions\n    growthFactor: 1.15, // More pronounced growth\n    foodPulseSpeed: 1800, // Slower pulse for food\n    foodPulseScale: 1.18, // Larger pulse scale\n    snakeGlowIntensity: 0.8, // Increased glow intensity\n    shadowPulseSpeed: 200, // Speed of shadow pulse\n    particleCount: 10,\n    particleLifetime: 1000,\n    particleGravity: 0.1,\n    particleSpeed: 2,\n    particleSize: 0.5,\n  },\n}\n\n// Responsive configuration\nexport const RESPONSIVE_CONFIG = {\n  mobileBreakpoint: 768, // Width threshold for mobile devices\n  touchMinDistance: 30, // Minimum swipe distance to trigger direction change\n  touchMaxTime: 300, // Maximum time for a swipe gesture\n  resizeDebounce: 250, // Debounce time for resize events\n}\n\n// Game configuration\nexport const GAME_CONFIG = {\n  gridSize: 20, // Number of cells in both width and height\n  initialSnakeLength: 3,\n  growthRate: 1,\n  maxHighScores: 5,\n  controls: {\n    up: [\"ArrowUp\", \"w\", \"W\"],\n    down: [\"ArrowDown\", \"s\", \"S\"],\n    left: [\"ArrowLeft\", \"a\", \"A\"],\n    right: [\"ArrowRight\", \"d\", \"D\"],\n    pause: [\"Space\", \"p\", \"P\"],\n    restart: [\"r\", \"R\"],\n  },\n}\n\n// Helper functions\nexport const getCanvasSize = (containerWidth, containerHeight) => {\n  const { minTileSize, maxTileSize } = THEME.dimensions\n  const { gridSize } = GAME_CONFIG\n\n  // Calculate the maximum possible cell size that fits in both dimensions\n  const maxPossibleCellSize = Math.min(\n    Math.floor(containerWidth / gridSize),\n    Math.floor(containerHeight / gridSize)\n  )\n\n  // Clamp the cell size between min and max\n  const cellSize = Math.max(\n    minTileSize,\n    Math.min(maxPossibleCellSize, maxTileSize)\n  )\n\n  // Calculate the final canvas size to ensure perfect squares\n  return {\n    width: cellSize * gridSize,\n    height: cellSize * gridSize,\n    cellSize: cellSize,\n  }\n}\n\nexport const getCellSize = (canvasSize) => {\n  return canvasSize.cellSize\n}\n","import * as Tone from 'tone'\n\nclass SoundManager {\n    constructor() {\n        // Initialize synths\n        this.foodSynth = new Tone.Synth({\n            oscillator: {\n                type: \"sine\"\n            },\n            envelope: {\n                attack: 0.01,\n                decay: 0.1,\n                sustain: 0,\n                release: 0.1\n            }\n        }).toDestination()\n\n        this.gameOverSynth = new Tone.PolySynth(Tone.Synth, {\n            oscillator: {\n                type: \"triangle\"\n            },\n            envelope: {\n                attack: 0.01,\n                decay: 0.3,\n                sustain: 0,\n                release: 0.1\n            }\n        }).toDestination()\n\n        this.moveSynth = new Tone.Synth({\n            oscillator: {\n                type: \"square\"\n            },\n            envelope: {\n                attack: 0.01,\n                decay: 0.05,\n                sustain: 0,\n                release: 0.05\n            },\n            volume: -20\n        }).toDestination()\n\n        // Initialize effects\n        this.feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination()\n        this.gameOverSynth.connect(this.feedbackDelay)\n    }\n\n    async initialize() {\n        // Only initialize if context is not running\n        if (Tone.context.state !== 'running') {\n            try {\n                await Tone.start()\n                console.log('Audio context started')\n            } catch (error) {\n                console.warn('Could not start audio context:', error)\n            }\n        }\n    }\n\n    playFoodCollect() {\n        this.foodSynth.triggerAttackRelease(\"C5\", \"16n\")\n    }\n\n    playGameOver() {\n        // Play a descending pattern\n        const now = Tone.now()\n        this.gameOverSynth.triggerAttackRelease([\"C4\", \"G3\", \"E3\", \"C3\"], \"8n\", now)\n    }\n\n    playMove() {\n        this.moveSynth.triggerAttackRelease(\"G4\", \"32n\")\n    }\n}\n\n// Create and export a singleton instance\nconst soundManager = new SoundManager()\nexport { soundManager }\n","// External dependencies\nimport { Scene } from 'phaser'\nimport { \n  THEME, \n  GAME_CONFIG\n} from './constants'\nimport profile1 from '../../../assets/images/profile1-nbg.png'\nimport { soundManager as sound } from './sounds'\n\nexport class SnakeScene extends Scene {\n  constructor(isMobile = false) {\n    super({ key: 'SnakeScene' })\n    this.state = {\n      snake: [],\n      food: null,\n      direction: { x: 0, y: 0 },\n      nextDirection: { x: 0, y: 0 },\n      score: 0,\n      gameOver: false,\n      lastUpdate: 0\n    }\n    this.particles = []\n    this.currentHue = 0\n    this.snakeHue = 180 // Starting color for snake\n    this.foodHue = 0    // Starting color for food\n    this.isMobile = isMobile\n    this.gameSpeed = isMobile ? THEME.animations.snakeSpeed.mobile : THEME.animations.snakeSpeed.desktop\n    this.highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0\n    this.avatar = new Image()\n    this.avatar.src = profile1\n    this.boundKeyHandler = null\n  }\n\n  async create(canvasSize) {\n    this.canvasSize = canvasSize\n    this.cellSize = canvasSize.cellSize // Use the precalculated cell size\n    await sound.initialize()\n    this.initializeGame()\n    this.setupInput()\n    this.setupEventListeners()\n  }\n\n  initializeGame() {\n    const centerX = Math.floor(GAME_CONFIG.gridSize / 2) * this.cellSize\n    const centerY = Math.floor(GAME_CONFIG.gridSize / 2) * this.cellSize\n    \n    this.state.snake = [{ x: centerX, y: centerY }]\n    this.state.direction = { x: this.cellSize, y: 0 }\n    this.state.nextDirection = { x: this.cellSize, y: 0 }\n    this.spawnFood()\n    this.state.score = 0\n    this.state.gameOver = false\n  }\n\n  setupInput() {\n    this.boundKeyHandler = (event) => {\n      this.handleKeyPress(event.code)\n      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {\n        event.preventDefault()\n      }\n    }\n    document.addEventListener('keydown', this.boundKeyHandler)\n  }\n\n  handleKeyPress(key) {\n    if (this.state.gameOver) {\n      if (key === 'Space' || key === 'Enter') {\n        this.initializeGame()\n        return\n      }\n    }\n\n    const { direction } = this.state\n    const cellSize = this.cellSize\n    \n    switch(key) {\n      case 'ArrowUp':\n        if (direction.y === 0) {\n          this.state.nextDirection = { x: 0, y: -cellSize }\n        }\n        break\n      case 'ArrowDown':\n        if (direction.y === 0) {\n          this.state.nextDirection = { x: 0, y: cellSize }\n        }\n        break\n      case 'ArrowLeft':\n        if (direction.x === 0) {\n          this.state.nextDirection = { x: -cellSize, y: 0 }\n        }\n        break\n      case 'ArrowRight':\n        if (direction.x === 0) {\n          this.state.nextDirection = { x: cellSize, y: 0 }\n        }\n        break\n      case 'Space':\n      case 'Enter':\n        if (this.state.gameOver) {\n          this.initializeGame()\n        }\n        break\n      default:\n        break\n    }\n  }\n\n  generateFoodPosition() {\n    const x = Math.floor(Math.random() * (this.canvasSize.width / this.cellSize)) * this.cellSize\n    const y = Math.floor(Math.random() * (this.canvasSize.height / this.cellSize)) * this.cellSize\n    return { x, y }\n  }\n\n  isValidFoodPosition(food) {\n    return !this.state.snake.some(segment => this.isCollision(segment, food))\n  }\n\n  spawnFood() {\n    let newFood\n    do {\n      newFood = this.generateFoodPosition()\n    } while (!this.isValidFoodPosition(newFood))\n    \n    this.state.food = newFood\n  }\n\n  isCollision(pos1, pos2) {\n    const tolerance = this.cellSize / 4 // Add some tolerance for collision detection\n    return Math.abs(pos1.x - pos2.x) < tolerance && Math.abs(pos1.y - pos2.y) < tolerance\n  }\n\n  createParticles() {\n    const { food } = this.state\n    const particleCount = 10\n    const baseHue = this.foodHue // Use current food hue for particles\n    \n    for (let i = 0; i < particleCount; i++) {\n      const angle = (Math.PI * 2 * i) / particleCount\n      const speed = 2 + Math.random() * 2\n      const size = 2 + Math.random() * 3\n      \n      this.particles.push({\n        x: food.x + this.cellSize / 2,\n        y: food.y + this.cellSize / 2,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size,\n        life: 1,\n        hue: (baseHue + Math.random() * 30) % 360,\n        draw: function() {\n          if (this.life <= 0) return\n          \n          const ctx = this.game.context\n          ctx.beginPath()\n          ctx.fillStyle = `hsla(${this.hue}, 70%, 50%, ${this.life})`\n          ctx.shadowColor = `hsla(${this.hue}, 80%, 60%, ${this.life})`\n          ctx.shadowBlur = 5\n          ctx.fillRect(this.x, this.y, this.size, this.size)\n          ctx.shadowBlur = 0\n          \n          // Update position and life\n          this.x += this.vx\n          this.y += this.vy\n          this.life -= 0.05\n        }.bind(this)\n      })\n    }\n  }\n\n  update(time) {\n    if (this.state.gameOver) {\n      return\n    }\n\n    // Update colors\n    this.snakeHue = (this.snakeHue + 0.5) % 360\n    this.foodHue = (this.foodHue + 1) % 360\n\n    // Check if enough time has passed since last update\n    if (time - this.state.lastUpdate < this.gameSpeed) {\n      return\n    }\n    \n    this.state.lastUpdate = time\n    this.moveSnake()\n    if (this.checkCollisions()) {\n      return\n    }\n    this.draw()\n    this.updateParticles()\n  }\n\n  checkCollisions() {\n    const { snake } = this.state\n    const head = snake[0]\n    \n    // Check self collision\n    for (let i = 1; i < snake.length; i++) {\n      if (this.isCollision(head, snake[i])) {\n        this.state.gameOver = true\n        sound.playGameOver()\n        return true\n      }\n    }\n    return false\n  }\n\n  moveSnake() {\n    const { snake, nextDirection, food } = this.state\n    const head = { ...snake[0] }\n    \n    this.state.direction = nextDirection\n    head.x += nextDirection.x\n    head.y += nextDirection.y\n\n    // Wrap around walls\n    const width = this.canvasSize.width\n    const height = this.canvasSize.height\n    \n    if (head.x >= width) head.x = 0\n    if (head.x < 0) head.x = width - this.cellSize\n    if (head.y >= height) head.y = 0\n    if (head.y < 0) head.y = height - this.cellSize\n\n    snake.unshift(head)\n    \n    // Check food collision\n    if (this.isCollision(head, food)) {\n      // Play food collection sound\n      sound.playFoodCollect()\n      \n      // Increment score\n      this.state.score++\n      \n      // Create particles\n      this.createParticles()\n      \n      // Spawn new food\n      this.spawnFood()\n      \n      // Update high score\n      if (this.state.score > this.highScore) {\n        this.highScore = this.state.score\n        localStorage.setItem('snakeHighScore', this.state.score)\n      }\n      \n      // Don't remove tail to grow snake\n    } else {\n      // Remove tail if no food was eaten\n      snake.pop()\n    }\n  }\n\n  updateParticles() {\n    for (let i = this.particles.length - 1; i >= 0; i--) {\n      this.particles[i].draw()\n      if (this.particles[i].life <= 0) {\n        this.particles.splice(i, 1)\n      }\n    }\n  }\n\n  draw() {\n    const { snake, food } = this.state\n    const ctx = this.game.context\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, this.canvasSize.width, this.canvasSize.height)\n    \n    // Draw grid\n    this.drawGrid()\n    \n    // Draw snake with color cycling\n    snake.forEach((segment, index) => {\n      const isHead = index === 0\n      ctx.beginPath()\n      \n      // Create gradient based on position in snake\n      const segmentHue = (this.snakeHue + (index * 5)) % 360\n      const baseColor = `hsl(${segmentHue}, 70%, ${isHead ? 60 : 50}%)`\n      const glowColor = `hsl(${segmentHue}, 80%, 60%)`\n      \n      ctx.fillStyle = baseColor\n      ctx.shadowColor = glowColor\n      ctx.shadowBlur = isHead ? 15 : 10\n      ctx.fillRect(segment.x, segment.y, this.cellSize - 1, this.cellSize - 1)\n    })\n    ctx.shadowBlur = 0\n    \n    // Draw food if it exists\n    if (food) {\n      ctx.save()\n      \n      // Create color overlay\n      const foodColor = `hsl(${this.foodHue}, 70%, 50%)`\n      const foodGlow = `hsl(${this.foodHue}, 80%, 60%)`\n      \n      // Add glow effect\n      ctx.shadowColor = foodGlow\n      ctx.shadowBlur = 15\n      \n      // Draw the avatar image\n      ctx.drawImage(\n        this.avatar,\n        food.x,\n        food.y,\n        this.cellSize - 1,\n        this.cellSize - 1\n      )\n      \n      // Add colored overlay\n      ctx.globalCompositeOperation = 'overlay'\n      ctx.fillStyle = foodColor\n      ctx.fillRect(food.x, food.y, this.cellSize - 1, this.cellSize - 1)\n      \n      // Add pixelation effect\n      ctx.globalCompositeOperation = 'source-over'\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'\n      const pixelSize = 2\n      for (let x = 0; x < this.cellSize - 1; x += pixelSize) {\n        for (let y = 0; y < this.cellSize - 1; y += pixelSize) {\n          if ((x + y) % 4 === 0) {\n            ctx.fillRect(food.x + x, food.y + y, pixelSize, pixelSize)\n          }\n        }\n      }\n      \n      ctx.restore()\n    }\n    \n    // Draw particles\n    this.particles.forEach(particle => particle.draw())\n  }\n\n  drawGrid() {\n    const ctx = this.game.context\n    ctx.strokeStyle = THEME.colors.gridLines\n    ctx.lineWidth = this.isMobile ? 0.5 : 1\n    \n    for (let i = 0; i < GAME_CONFIG.gridSize; i++) {\n      const pos = i * this.cellSize\n      ctx.beginPath()\n      ctx.moveTo(pos, 0)\n      ctx.lineTo(pos, this.canvasSize.height)\n      ctx.stroke()\n      ctx.beginPath()\n      ctx.moveTo(0, pos)\n      ctx.lineTo(this.canvasSize.width, pos)\n      ctx.stroke()\n    }\n  }\n\n  updateGridSize() {\n    // Recalculate positions based on new cell size\n    this.state.snake = this.state.snake.map(segment => ({\n      x: Math.round(segment.x / this.cellSize) * this.cellSize,\n      y: Math.round(segment.y / this.cellSize) * this.cellSize\n    }))\n\n    if (this.state.food) {\n      this.state.food = {\n        x: Math.round(this.state.food.x / this.cellSize) * this.cellSize,\n        y: Math.round(this.state.food.y / this.cellSize) * this.cellSize\n      }\n    }\n\n    // Ensure snake and food are within bounds\n    this.keepInBounds()\n  }\n\n  keepInBounds() {\n    const maxX = this.canvasSize.width - this.cellSize\n    const maxY = this.canvasSize.height - this.cellSize\n\n    // Adjust snake segments\n    this.state.snake = this.state.snake.map(segment => ({\n      x: Math.max(0, Math.min(segment.x, maxX)),\n      y: Math.max(0, Math.min(segment.y, maxY))\n    }))\n\n    // Adjust food if it exists\n    if (this.state.food) {\n      this.state.food = {\n        x: Math.max(0, Math.min(this.state.food.x, maxX)),\n        y: Math.max(0, Math.min(this.state.food.y, maxY))\n      }\n    }\n  }\n\n  setupEventListeners() {\n    // Removed keyboard listener setup\n  }\n\n  cleanup() {\n    // Remove keyboard event listeners\n    if (this.boundKeyHandler) {\n      document.removeEventListener('keydown', this.boundKeyHandler)\n      this.boundKeyHandler = null\n    }\n\n    // Clear game state\n    this.state = {\n      snake: [],\n      food: null,\n      direction: { x: 0, y: 0 },\n      nextDirection: { x: 0, y: 0 },\n      score: 0,\n      gameOver: false,\n      lastUpdate: 0\n    }\n\n    // Clear particles\n    this.particles = []\n\n    // Clear canvas if it exists\n    if (this.game && this.game.context && this.canvasSize) {\n      this.game.context.clearRect(0, 0, this.canvasSize.width, this.canvasSize.height)\n    }\n\n    // Stop any ongoing animations\n    if (this.game && this.game.animationFrameId) {\n      cancelAnimationFrame(this.game.animationFrameId)\n      this.game.animationFrameId = null\n    }\n  }\n}","import React, { useEffect, useRef, useState, useCallback } from 'react'\nimport { getCanvasSize, RESPONSIVE_CONFIG, GAME_CONFIG } from './constants'\nimport { SnakeScene } from './snake'\nimport FullscreenWrapper from '../FullscreenWrapper'\nimport profile1 from '../../../assets/images/profile1-nbg.png'\nimport './snake.scss'\n\nconst SnakeGame = () => {\n  const containerRef = useRef(null)\n  const canvasRef = useRef(null)\n  const gameInstanceRef = useRef(null)\n  const resizeTimeoutRef = useRef(null)\n  const [isGameOver, setIsGameOver] = useState(false)\n  const [score, setScore] = useState(0)\n  const [highScore, setHighScore] = useState(\n    parseInt(localStorage.getItem('snakeHighScore')) || 0\n  )\n  const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 })\n  const [isMobile, setIsMobile] = useState(false)\n  const touchStartRef = useRef({ x: 0, y: 0, time: 0 })\n\n  const handleResize = useCallback(() => {\n    if (resizeTimeoutRef.current) {\n      clearTimeout(resizeTimeoutRef.current)\n    }\n\n    resizeTimeoutRef.current = setTimeout(() => {\n      if (containerRef.current) {\n        try {\n          const container = containerRef.current\n          const { width, height } = container.getBoundingClientRect()\n          const newSize = getCanvasSize(width, height)\n          \n          // Only update if size actually changed\n          if (newSize.width !== canvasSize.width || newSize.height !== canvasSize.height) {\n            setCanvasSize(newSize)\n            setIsMobile(width <= RESPONSIVE_CONFIG.mobileBreakpoint)\n\n            // Update canvas size\n            if (canvasRef.current) {\n              canvasRef.current.width = newSize.width\n              canvasRef.current.height = newSize.height\n            }\n\n            // Update game instance\n            if (gameInstanceRef.current) {\n              gameInstanceRef.current.canvasSize = newSize\n              gameInstanceRef.current.updateGridSize()\n            }\n          }\n        } catch (error) {\n          console.error('Error during resize:', error)\n        }\n      }\n    }, 250)\n  }, [canvasSize])\n\n  useEffect(() => {\n    handleResize()\n    \n    let resizeObserver\n    try {\n      resizeObserver = new ResizeObserver((entries) => {\n        // Avoid infinite loops by checking if size actually changed\n        const entry = entries[0]\n        if (entry && entry.contentRect) {\n          handleResize()\n        }\n      })\n\n      if (containerRef.current) {\n        resizeObserver.observe(containerRef.current)\n      }\n    } catch (error) {\n      console.warn('ResizeObserver error:', error)\n    }\n\n    window.addEventListener('resize', handleResize)\n    window.addEventListener('orientationchange', handleResize)\n\n    return () => {\n      if (resizeTimeoutRef.current) {\n        clearTimeout(resizeTimeoutRef.current)\n      }\n      if (resizeObserver) {\n        resizeObserver.disconnect()\n      }\n      window.removeEventListener('resize', handleResize)\n      window.removeEventListener('orientationchange', handleResize)\n    }\n  }, [handleResize])\n\n  useEffect(() => {\n    if (canvasRef.current && containerRef.current && canvasSize.width && canvasSize.height) {\n      const canvas = canvasRef.current\n      const ctx = canvas.getContext('2d')\n      \n      // Set canvas size\n      canvas.width = canvasSize.width\n      canvas.height = canvasSize.height\n      \n      // Initialize game\n      const game = new SnakeScene(isMobile)\n      game.game = { context: ctx, canvas }\n      game.create(canvasSize)\n      gameInstanceRef.current = game\n\n      // Focus the canvas for keyboard input\n      canvas.setAttribute('tabindex', '0')\n      canvas.focus()\n\n      // Animation loop\n      let animationFrameId\n      const render = (time) => {\n        if (!game.state.gameOver) {\n          game.update(time)\n          setScore(game.state.score)\n          if (game.state.gameOver) {\n            setIsGameOver(true)\n            if (game.state.score > highScore) {\n              setHighScore(game.state.score)\n              localStorage.setItem('snakeHighScore', game.state.score)\n            }\n          }\n          animationFrameId = window.requestAnimationFrame(render)\n        }\n      }\n      render(0)\n\n      // Cleanup\n      return () => {\n        window.cancelAnimationFrame(animationFrameId)\n        if (game.cleanup) {\n          game.cleanup()\n        }\n        gameInstanceRef.current = null\n      }\n    }\n  }, [canvasSize, isMobile, highScore])\n\n  const handleRestart = useCallback(() => {\n    if (gameInstanceRef.current) {\n      gameInstanceRef.current.initializeGame()\n      setIsGameOver(false)\n      setScore(0)\n      if (canvasRef.current) {\n        canvasRef.current.focus()\n      }\n    }\n  }, [])\n\n  const handleTouchStart = (e) => {\n    const touch = e.touches[0]\n    touchStartRef.current = {\n      x: touch.clientX,\n      y: touch.clientY,\n      time: Date.now()\n    }\n  }\n\n  const handleTouchEnd = (e) => {\n    const touch = e.changedTouches[0]\n    const deltaX = touch.clientX - touchStartRef.current.x\n    const deltaY = touch.clientY - touchStartRef.current.y\n    const deltaTime = Date.now() - touchStartRef.current.time\n\n    if (deltaTime < GAME_CONFIG.touchThreshold.time) {\n      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n      if (distance > GAME_CONFIG.touchThreshold.distance) {\n        const angle = Math.atan2(deltaY, deltaX)\n        const direction = Math.round(angle / (Math.PI / 2))\n        \n        if (gameInstanceRef.current) {\n          switch (((direction + 4) % 4)) {\n            case 0: gameInstanceRef.current.setDirection('right'); break\n            case 1: gameInstanceRef.current.setDirection('down'); break\n            case 2: gameInstanceRef.current.setDirection('left'); break\n            case 3: gameInstanceRef.current.setDirection('up'); break\n            default: break\n          }\n        }\n      }\n    }\n  }\n\n  return (\n    <FullscreenWrapper>\n      <div ref={containerRef} className=\"snake-tool\">\n        <div className=\"game-container\">\n          <div className=\"score-display\">\n            <div className=\"score\">\n              <span>Score</span>\n              <span>{String(score).padStart(2, '0')}</span>\n            </div>\n            <div className=\"high-score\">\n              <span>Best</span>\n              <span>{String(highScore).padStart(2, '0')}</span>\n            </div>\n            {score > 0 && score >= highScore && (\n              <div className=\"profile-badge\">\n                <img src={profile1} alt=\"Profile\" />\n                <div className=\"badge-label\">New Best!</div>\n              </div>\n            )}\n          </div>\n          <canvas\n            ref={canvasRef}\n            className=\"game-canvas\"\n            onTouchStart={handleTouchStart}\n            onTouchEnd={handleTouchEnd}\n          />\n          {isGameOver && (\n            <div className=\"game-over\">\n              <div className=\"game-over-content\">\n                <div className=\"profile-container\">\n                  <img src={profile1} alt=\"Profile\" className=\"profile-image\" />\n                  <div className=\"pixel-overlay\"></div>\n                </div>\n                <h2 data-text=\"GAME OVER\">GAME OVER</h2>\n                <div className=\"score-message\">\n                  {score === highScore && score > 0 ? (\n                    <>\n                      <div className=\"score-banner\">\n                        <span className=\"star\">★</span>\n                        <span className=\"new-record\">NEW RECORD!</span>\n                        <span className=\"star\">★</span>\n                      </div>\n                      <p className=\"score-value\">Score: {String(score).padStart(2, '0')}</p>\n                      <p className=\"encouraging-text\">You're unstoppable!</p>\n                    </>\n                  ) : (\n                    <>\n                      <p className=\"score-value\">Score: {String(score).padStart(2, '0')}</p>\n                      <p className=\"high-score-value\">Best: {String(highScore).padStart(2, '0')}</p>\n                      <p className=\"encouraging-text\">\n                        {score === 0 ? \"Don't give up!\" : \n                         score < 5 ? \"You can do better!\" :\n                         score < 10 ? \"Getting better!\" :\n                         score < highScore ? \"Almost there!\" :\n                         \"Great job!\"}\n                      </p>\n                    </>\n                  )}\n                </div>\n                <div className=\"game-over-buttons\">\n                  <button onClick={handleRestart} className=\"play-again-btn\">\n                    <span className=\"btn-text\">PLAY AGAIN</span>\n                    <span className=\"btn-icon\">↺</span>\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </FullscreenWrapper>\n  )\n}\n\nexport default SnakeGame\n"],"names":["THEME","background","snake","gradient","glow","snakeHead","food","border","gridLines","text","gameOver","scoreBackground","highScore","minTileSize","maxTileSize","borderRadius","gridLineWidth","shadowBlur","glowRadius","innerShadowSize","snakeSpeed","mobile","desktop","fadeSpeed","growthFactor","foodPulseSpeed","foodPulseScale","snakeGlowIntensity","shadowPulseSpeed","particleCount","particleLifetime","particleGravity","particleSpeed","particleSize","RESPONSIVE_CONFIG","GAME_CONFIG","gridSize","initialSnakeLength","growthRate","maxHighScores","controls","up","down","left","right","pause","restart","soundManager","constructor","this","foodSynth","Tone","oscillator","type","envelope","attack","decay","sustain","release","toDestination","gameOverSynth","moveSynth","volume","feedbackDelay","connect","initialize","state","console","log","error","warn","playFoodCollect","triggerAttackRelease","playGameOver","now","playMove","SnakeScene","Scene","isMobile","arguments","length","undefined","super","key","direction","x","y","nextDirection","score","lastUpdate","particles","currentHue","snakeHue","foodHue","gameSpeed","parseInt","localStorage","getItem","avatar","Image","src","profile1","boundKeyHandler","create","canvasSize","cellSize","sound","initializeGame","setupInput","setupEventListeners","centerX","Math","floor","centerY","spawnFood","event","handleKeyPress","code","includes","preventDefault","document","addEventListener","generateFoodPosition","random","width","height","isValidFoodPosition","some","segment","isCollision","newFood","pos1","pos2","tolerance","abs","createParticles","baseHue","i","angle","PI","speed","size","push","vx","cos","vy","sin","life","hue","draw","ctx","game","context","beginPath","fillStyle","concat","shadowColor","fillRect","bind","update","time","moveSnake","checkCollisions","updateParticles","head","_objectSpread","unshift","setItem","pop","splice","clearRect","drawGrid","forEach","index","isHead","segmentHue","baseColor","glowColor","save","foodColor","foodGlow","drawImage","globalCompositeOperation","pixelSize","restore","particle","strokeStyle","lineWidth","pos","moveTo","lineTo","stroke","updateGridSize","map","round","keepInBounds","maxX","maxY","max","min","cleanup","removeEventListener","animationFrameId","cancelAnimationFrame","SnakeGame","containerRef","useRef","canvasRef","gameInstanceRef","resizeTimeoutRef","isGameOver","setIsGameOver","useState","setScore","setHighScore","setCanvasSize","setIsMobile","touchStartRef","handleResize","useCallback","current","clearTimeout","setTimeout","container","getBoundingClientRect","newSize","getCanvasSize","containerWidth","containerHeight","maxPossibleCellSize","useEffect","resizeObserver","ResizeObserver","entries","entry","contentRect","observe","window","disconnect","canvas","getContext","setAttribute","focus","render","requestAnimationFrame","handleRestart","_jsx","FullscreenWrapper","children","ref","className","_jsxs","String","padStart","alt","onTouchStart","e","touch","touches","clientX","clientY","Date","onTouchEnd","changedTouches","deltaX","deltaY","touchThreshold","sqrt","distance","atan2","setDirection","_Fragment","onClick"],"sourceRoot":""}